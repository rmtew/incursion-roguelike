/* RES.H -- Copyright (c) 1999-2003 Julian Mensch
     This file contains class definitions for Resource and
   its derived classes, Module, Game, Annotation and VMachine,
   as well as a host of macros used fo accessing resources in
   different circumstances.
*/


#define RES(l) ( theGame->Get(l) )
#define TMON(l) ( (TMonster*) theGame->Get(l) )
#define TITEM(l) ( (TItem*) theGame->Get(l) )
#define TEFF(l) ( (TEffect*) theGame->Get(l) )
#define TFEAT(l) ( (TFeature*) theGame->Get(l) )
#define TQUEST(l) ( (TQuest*) theGame->Get(l) )
#define TRACE(l) ( (TRace*) theGame->Get(l) )
#define TCLASS(l) ( (TClass*) theGame->Get(l) )
#define TART(l) ( (TArtifact*) theGame->Get(l) )
#define TDUN(l) ( (TDungeon*) theGame->Get(l) )
#define TTER(l) ( (TTerrain*) theGame->Get(l) )
#define TREG(l) ( (TRegion*) theGame->Get(l) )
#define TDOM(l) ( (TDomain*) theGame->Get(l) )
#define TGOD(l) ( (TGod*) theGame->Get(l) )
#define TTEM(l) ( (TTemplate*) theGame->Get(l) )
#define TFLA(l) ( (TFlavor*) theGame->Get(l) )
#define TTEX(l) ( (TText*) theGame->Get(l) )
#define TBEV(l) ( (TBehaviour*) theGame->Get(l) )
#define TENC(l) ( (TEncounter*) theGame->Get(l) )

#define NAME(l) ( (const char*) (l ? RES(l)->GetName(0) : "{null}") )
#define DESC(l) ( l ? theGame->GetDesc(l) : "{null}" )

#define FIND(str)  ( theGame->Find(str) )

#define MONMEM(xID,p) ( (MonMem*) theGame->GetMemory(xID,p) )
#define ITMMEM(xID,p) ( (ItemMem*) theGame->GetMemory(xID,p) )
#define EFFMEM(xID,p) ( (EffMem*) theGame->GetMemory(xID,p) )
#define REGMEM(xID,p) ( (RegMem*) theGame->GetMemory(xID,p) )


#define SMON(str) ( (TMonster*) theGame->Get(theGame->Find(str)) )
#define SITEM(str) ( (TItem*) theGame->Get(theGame->Find(str)) )
#define SEFF(str) ( (TEffect*) theGame->Get(theGame->Find(str)) )
#define SFEAT(str) ( (TFeature*) theGame->Get(theGame->Find(str)) )
#define SMAP(str) ( (TMap*) theGame->Get(theGame->Find(str)) )

#define yyDice(dv) (*((Dice*)(&dv)))

struct Annotation;

struct Breakpoint
  {
    rID     xID;
    int16   Event;
    hCode   Location;
    bool    Active;
  };

class TextTerm;

class VMachine
  {
    friend const char* __XPrint(Player *POV, const char *msg,va_list args);
    friend class TextTerm;
    private:
      static int32 Regs[64]; /* The Registers */
      static String SRegs[64];
      static int32 Stack[8192];
      static String VStr[256];
      static uint32 StrUsed[(256 / 8)+1];
      static Breakpoint Breakpoints[64];
      static int16 nBreakpoints;
      static int32*Memory;
      static int32 szMemory;
      int8 mn; rID xID;
      bool   isTracing;
      inline int32 Value1(VCode *);
      inline int32 Value2(VCode *);
      inline int32*LValue1(VCode *);
      EventInfo *pe; Object *Subject;
    public:
      int32 Execute(EventInfo *e, rID xID, hCode CP);
      int32 Execute(Thing*t,rID xID, hCode CP);
      int32* getMemorySafe(int32 a);
      int32* getStackSafe(int32 a);
      int32* getRegSafe(int32 n);
      String & getStringSafe(hText ht);
      Object* GetSystemObject(hObj h);
      String & LookupParam(uint16 Type,int32 Value, rID xID, int16 Ev, int16 op, int16 pn);
    private:
      void SystemFunc(int16 funcid, int32 param);
      /* These three functions are automatically generated by the
         resource compiler (if the GENERATE_DISPATCH flag is set)
         from the interface declarations in dispatch.h. */
      void CallMemberFunc(int16 funcid, hObj h, int8 n);
      void GetMemberVar(int16 varid, hObj h, int8 n);
      void SetMemberVar(int16 varid, hObj h, int32 val);
  };

struct DebugInfo
  {
    rID    xID;
    int16  Event;
    int16  VarType, 
           RType;
    int32  Address;
    btype  BType;
    int16  DataType;
    char   Ident[32];
  };

struct TAttack
	{
		int8 AType, DType;
    union {
      struct {
        Dice Dmg; 
        int8 DC;
        } a;
      rID xID;
      } u;
    void Dump();
	};

struct EffectValues
  {
    /* These are the same, regardless of archetype */
    int8  eval;       /* effect value   (basic archetype) */
    int8  dval;       /* distance value (range of effect) */
    int8  aval;       /* area value  (area of effect) */
    int8  tval;       /* target value (what is affected?) */
    int8  qval;       /* query value (prompt flags) */
    int8  sval;       /* save value (saving throw) */
    int8  lval;       /* level value (i.e., max HD, radius, etc.) */
    int8  cval;       /* colour of blast effect */
    /* These vary meaning based on the effect archetype */
    rID   rval;       /* resource value (or extra flags) */
    uint8 xval;       /* misc. value (stati #, DType, etc.) */
    int16 yval;       /* second misc. value (Stati Val, etc.) */
    Dice  pval;       /* power value (damage/healing/Mag) */
  };  

struct Tile
  {
    rID tID, xID, xID2;
    Glyph Image;
    uint8 fl;
    char ch;
  };

/* DO NOT UNDER ANY CIRCUMSTANCES CHANGE THE SIZE OF THE ARRAYS HERE
   without noting it to everyone who works with this code, or it will
   result in horrible and difficult to trace memory corruption errors
   with the annotations. */

struct Annotation
  {
    Annotation() { memset(this,0,sizeof(Annotation)); }
    int32 Next; uint8 AnType;
	  void AddToMap(Map *m, uint16 dx=0,uint16 dy=0);
    union
      {
        struct {
          rID sID;
          } sp[8];
        struct EffectValues ef;
        struct {
          rID iID, eID;
          uint8 Chance, Flags, Spec;
          Dice Amount;
          uint8 Qualities[4];
          hCode Condition;
          uint8 x,y,z;
          } eq;
        struct {
          hText msg[3];
          uint8 Event;
          } ep[2];
        struct {
          uint32 MsgOrCode;
          int16 Event;
          } ev[5];
        struct {
          rID xID;
          uint8 x,y;
          uint16 EFlags;
          } me[4];
        struct Tile ti[2];
        struct {
          int8 AbType;
          uint16 Ability; // feats go beyond 255 
          uint32 Param;
          int8 Lev1, Lev2;
          } ab[4];
        struct {
          uint8 Const;
          int32 Value;
          } dc[6];
        struct {
          uint8 Const;
          rID xID[7];
          } dl;
        struct {
          rID xID;
          Dice Lev;
          int8 Chance;
          } ds[4];
        struct {
          int8 AbType;
          uint32 Power; /* Effect rID, Feat # or Stati # */
          int16 Param;
          Dice Charge;
          } ap[3];
      } u;
    void Dump(); // ww: debugging
  };
    

class Resource {
	public:
      int16 Type;
      int8 ModNum;
      uint16 EventMask;
      static Annotation *cAnnot, *cAnnot2;
      static String EvMsg[64];
      Resource(int16 _Type)  { Type = _Type; AnHead = 0; }
      bool isType(int16 rt) { /*if (rt == T_TRESOURCE)
                                return true;*/
                              return rt == Type; }
      void Dump();
			hText Name, Desc;
      int32 AnHead;

      String & GetName(uint16 fl);

      void AddResID(int8 at, rID sID);
                                                                             
      void AddAbility(int8 at,int16 ab,uint32 p,int8 l1,int8 l2);
      void AddElement(rID eID,int8 x,int8 y,uint16 fl);
      void AddEvent(int16 ev, uint32 moc);
      void AddChatter(uint8,const char*m1,const char*m2,const char*m3,
                              const char*m4,const char*m5);
      void AddEquip(uint8 Chance,Dice amt,rID iID,rID eID,int8 spec,
                      uint8 qual[4],uint8 fl, hCode cond);
      void AddTile(char ch, Glyph img, uint8 fl, rID tID, rID xID, rID xID2);
      Tile* GetTile(char ch);
      void AddParam(int8 p,int16 v);
      void AddArray(int8 p,int16 *list);
      void AddConstant(int8 con,int32 val);
      void AddList(int8 ln, uint32 *lv);
      void AddSpecial(rID xID,int16 Chance, int16 lev);
      void AddSpecial(rID xID,int16 Chance, Dice& lev);
      void AddPower(int8 apt,int8 pw,uint32 x,int16 pa,Dice*charge);
      uint32 GetConst(int16 cn);      
      bool GetList(int16 ln, rID *lv,int16 max);
      bool HasList(int16 ln);
      bool ListHasItem(int16 ln, int32 look_for);
      rID  GetRes(int16 at, bool first);
      rID FirstRes(int16 at)
        { return GetRes(at,true); }
      rID NextRes(int16 at)
        { return GetRes(at,false); }
      bool HasRes(rID xID, int16 at)
        { rID yID;
          for(yID=FirstRes(at);yID;yID=NextRes(at))
            if (yID == xID)
              return true;
          return false; }
      
      void GrantGear(Creature *c, rID xID, bool doRanged=true);

      bool HandlesEvent(uint8 ev); 
      EvReturn Event(EventInfo &e, rID xID, int16 Event=0);
      EvReturn PEvent(int16 ev, Thing *t, rID xID, int16 context=0);
      EvReturn PEvent(int16 ev, Thing *actor, 
                                Thing *item, rID xID, int16 context=0);
      String*  GetMessages(int16 ev);
      String & RandMessage(int16 ev);

      Annotation * Annot(int32 i);
      Annotation * FAnnot()
        { cAnnot = Annot(AnHead); return cAnnot; }
      Annotation * NAnnot()
        { cAnnot = (cAnnot && cAnnot->Next) ? Annot(cAnnot->Next) : NULL;
          return cAnnot; }
      Annotation * FAnnot2()
        { cAnnot2 = Annot(AnHead); return cAnnot2; }
      Annotation * NAnnot2()
        { cAnnot2 = (cAnnot2 && cAnnot2->Next) ? Annot(cAnnot2->Next) : NULL;
          return cAnnot2; }
      Annotation * NewAnnot(int8 at,int32*num, int32 *num2=NULL);
      /*virtual bool inGroup(hObj h);*/
      void* operator new(size_t sz)
        {
          void *vp;
          vp = malloc(sz);
          if (!vp)
            Fatal("Memory allocation error!");
          memset(vp,0,sz);
          return vp;
        }
      void* operator new[](size_t sz)
        {
          void *vp;
          vp = malloc(sz);
          if (!vp)
            Fatal("Memory allocation error!");
          memset(vp,0,sz);
          return vp;
        }

	};



struct Status
{
  // Status() { memset(this,0,sizeof(Status)); }
  unsigned int Nature :8;
  signed int Val      :16;
  signed int Mag      :16;
  signed int Duration :16;
  unsigned int Source :8;
  unsigned int CLev   :6;
  unsigned int Dis    :1;
  unsigned int Once   :1;
  signed int eID      :32;
  signed int h        :32;
};


class TMonster: public Resource
	{
		public:
      TMonster() : Resource(T_TMONSTER)  {}

      
			Glyph Image;               //The Glyph & Colour
			uint32 Terrains;
			int8 CR, Depth;
			int32 MType[3];         //Monster's Level, Type
			int8 Hit,Def,Arm;
      int8 Mov,Spd;
      int8 Attr[7];
			int16 HitDice, Mana;
      #define NUM_TMON_STATI 12
      Status Stati[NUM_TMON_STATI]; 
      #define NUM_TMON_ATTK 32
      TAttack Attk[NUM_TMON_ATTK];
			int8 Weight,
				Nutrition,
				Size;
      uint16 Feats[16];
			uint8 Flags[(M_LAST/8)+1];
			uint32 Imm;
			uint16 Res;
      int8 Advancement;
      void Dump();
      /* Note: Update to 12? */
    bool HasAttk(int8 x) { 
      for (int i=0;i<NUM_TMON_ATTK;i++)
        if (Attk[i].AType == x) return true;
      return false; 
    } 
    bool HasDType(int8 x) { 
      for (int i=0;i<NUM_TMON_ATTK;i++)
        if (Attk[i].DType == x) return true;
      return false; 
    } 
    bool HasAttk(int8 x, int8 d) { 
      for (int i=0;i<NUM_TMON_ATTK;i++)
        if (Attk[i].AType == x && Attk[i].DType == d) return true;
      return false; 
    } 
    TAttack* GetAttk(int8 x) { 
      for (int i=0;i<NUM_TMON_ATTK;i++)
        if (Attk[i].AType == x) return &Attk[i];
      return NULL;
    } 
      bool HasFeat(int16 ft) {
        for(int16 i=0;i!=16 && Feats[i];i++)
          if (Feats[i] == ft)
            return true;
        return false;
        }
      void SetFlag(uint16 fl)   { Flags[fl/8] |=  (1 << (fl % 8)); }
      void UnsetFlag(uint16 fl) { Flags[fl/8] &= ~(1 << (fl % 8)); }
      bool inline HasFlag(uint16 fl)   { return (Flags[fl/8] & (1 << (fl % 8))) != 0; }
      bool HasSlot(int16 sl);
      bool GainStati(uint8 Nature, int16 Val = 0, int16 Mag = 0, rID rr = 0)
        {
          for (int i = 0; i<NUM_TMON_STATI; i++) {
            if (Stati[i].Nature == 0) {
              Stati[i].Nature = Nature;
              Stati[i].Val = Val;
              Stati[i].Mag = Mag;
              Stati[i].Duration = -1; 
              Stati[i].eID = rr; 
              Stati[i].Source = SS_BODY; 
              return true; 
            } 
      } 
      return false; 
    } 

    uint8 MTypeCache[(MA_LAST/8) + 1];
    const inline bool isMType(rID tmid, uint32 mtype) 
    {
      if (mtype >= 256)
        return 
          (MTypeCache[(mtype%256)/8] & (1 << ((mtype%256) % 8))) &&
          (MTypeCache[(mtype/256)/8] & (1 << ((mtype/256) % 8)));
      return (MTypeCache[mtype/8] & (1 << (mtype % 8))) != 0;
    }
    void InitializeMTypeCache(rID tmid); 
	 };

class TItem: public Resource
	{
		public:
      TItem() : Resource(T_TITEM) { u.w.Crit = 2; u.w.Threat = 1; }
      void SetFlag(uint16 fl)   { Flags[fl/8] |=  (1 << (fl % 8)); }
      void UnsetFlag(uint16 fl) { Flags[fl/8] &= ~(1 << (fl % 8)); }
      bool inline HasFlag(uint16 fl)   { return (Flags[fl/8] & (1 << (fl % 8))) != 0; }
			int16 Image;
			int16 IType;
			int8  Level, Depth;
			int8  Material;
			int8  Nutrition;
      int16 Weight;
      uint16 hp; 
      int8 Size;
	  uint32 Cost, Group;
      union {
        struct {
          Dice SDmg, LDmg;
          int8 Crit, Threat, RangeInc,
            Acc, Spd, ParryMod;
          } w;
        struct {
          int8 Arm[3];
          int8 Cov, Def, Penalty;
          } a;
        struct {
          int8  Capacity;
          int8  MaxSize;
          int8  WeightMod;
          int8  CType;
          int8  Timeout;
          int16 WeightLim;
          } c;
        struct {
          int8  LightRange;
          int16 Lifespan;
          rID   Fuel;
          } l;
        } u;
      uint8 Flags[(IT_LAST/8)+1];
	};

class TFeature: public Resource
	{
 		public:
      TFeature() : Resource(T_TFEATURE) {}
			uint32 Flags;
			int16 Image;
			uint8 FType;
      uint8 Level;
      int8 MoveMod; 
      uint16 hp; 
      rID   xID;
      int16 xval;
      Dice  Factor;
			int8  Material;
	};

class TEffect: public Resource
	{
    public:
    TEffect() : Resource(T_TEFFECT) {  }
    String & Power(int8 Plus,Creature*caster, rID spID, Item *it=NULL);
    String & Describe(Player *p);
    EffectValues *Vals(int8 num);
    bool HasSource(int8 s)
      { return Sources[0] == s ||
                Sources[1] == s ||
                 Sources[2] == s ||
                   Sources[3] == s; }
    uint32 Schools; int8 Sources[4]; uint32 Purpose;
    uint8 ManaCost, BaseChance, SaveType; int8 Level;
    void SetFlag(uint16 fl)   { EFlags[fl/8] |=  (1 << (fl % 8)); }
    void UnsetFlag(uint16 fl) { EFlags[fl/8] &= ~(1 << (fl % 8)); }
    bool HasFlag(uint16 fl)   { return (EFlags[fl/8] & (1 << (fl % 8))) != 0; }
    uint8 EFlags[(EF_LAST/8)+1]; /* Effect Flags */
    EffectValues ef;
  };


struct LocationInfo;

class TQuest: public Resource
  {
    public:
    TQuest() : Resource(T_TQUEST) { }
    void SetFlag(uint16 fl)   { Flags[fl/8] |=  (1 << (fl % 8)); }
    void UnsetFlag(uint16 fl) { Flags[fl/8] &= ~(1 << (fl % 8)); }
    bool HasFlag(uint16 fl)   { return (Flags[fl/8] & (1 << (fl % 8))) != 0; }
    uint8 Flags[2];

  };


class TClass: public Resource
	{
    public:
      TClass() : Resource(T_TCLASS) { }
  		uint8 HitDie, ManaDie, DefMod;
		  uint8 Skills[40];
      uint8 Saves[3], AttkVal[4];
      uint8 SkillPoints;
      uint32 Proficiencies;
      void SetFlag(uint16 fl)   { Flags[fl/8] |=  (1 << (fl % 8)); }
      void UnsetFlag(uint16 fl) { Flags[fl/8] &= ~(1 << (fl % 8)); }
      bool HasFlag(uint16 fl)   { return (Flags[fl/8] & (1 << (fl % 8))) != 0; }
      bool HasSkill(int16 sk) 
        { int16 i;
          for(i=0;i!=40;i++)
            if (Skills[i] == sk)
              return true;
          return false; }
			uint8 Flags[(CF_LAST/8)+1];

	};

class TRace: public Resource
	{
    public:
      TRace() : Resource(T_TRACE) { }
    rID mID; rID BaseRace;
    rID FavouredClass[3];
		int8 AttrAdj[8];
		int8 Skills[12];
    hText MNames, FNames, SNames;
    void SetFlag(uint16 fl)   { Flags[fl/8] |=  (1 << (fl % 8)); }
    void UnsetFlag(uint16 fl) { Flags[fl/8] &= ~(1 << (fl % 8)); }
    bool HasFlag(uint16 fl)   { return (Flags[fl/8] & (1 << (fl % 8))) != 0; }
    bool HasSkill(int16 sk) 
      { int16 i;
        for(i=0;i!=6;i++)
          if (Skills[i] == sk)
            return true;
        return false; }
  	uint8 Flags[(CF_LAST/8)+1];
	};

class TDungeon: public Resource
  {
    public:
      TDungeon() : Resource(T_TDUNGEON) {  }
  };

class TRoutine: public Resource
  {
    public:
      TRoutine() : Resource(T_TROUTINE) { }
      hCode Location;
      int8  ParamTypes[10];
      int8  ParamCount;
      int8  ReturnType;
  };

class TNPC: public Resource
  {
    public:
      TNPC() : Resource(T_TNPC) { }
      int8 BaseAttrs[7];
      int8 StartingLevel;
      rID  ClassPath[36];
      int8 AttrBonuses[30];
      int8 FeatPriorities[50];
      rID  SpellPriorities[120];
      int8 SkillPriorities[30];
  };

class TArtifact: public Resource
  {
    public:
      TArtifact() : Resource(T_TARTIFACT) { }

      rID iID;
      int8 Bonus; int8 pval;
      int8 AttrAdjLow[7], AttrAdjHigh[7];
      uint32 Qualities;
      uint32 Resists;
      uint8  Sustains;
      void SetFlag(uint16 fl)   { Flags[fl/8] |=  (1 << (fl % 8)); }
      void UnsetFlag(uint16 fl) { Flags[fl/8] &= ~(1 << (fl % 8)); }
      bool HasFlag(uint16 fl)   { return (Flags[fl/8] & (1 << (fl % 8))) != 0; }
      uint8 Flags[(AF_LAST/8)+1];
  };

class TDomain: public Resource
  {
    public:
      TDomain() : Resource(T_TDOMAIN) { }
      int8 DType;
      rID  Spells[9];
      void SetFlag(uint16 fl)   { Flags[fl/8] |=  (1 << (fl % 8)); }
      void UnsetFlag(uint16 fl) { Flags[fl/8] &= ~(1 << (fl % 8)); }
      bool HasFlag(uint16 fl)   { return (Flags[fl/8] & (1 << (fl % 8))) != 0; }
			uint8 Flags[(DOF_LAST/8)+1];
      String & Describe(bool DescribeDomainSpells = false); 
  };

class TGod: public Resource
  {
    public:
      TGod() : Resource(T_TGOD) { }
      hText Ranks[8];
      rID Domains[12];  // ww: extra temp space
      rID ChosenWeapon;
      rID Artifacts[6];
      void SetFlag(uint16 fl)   { Flags[fl/8] |=  (1 << (fl % 8)); }
      void UnsetFlag(uint16 fl) { Flags[fl/8] &= ~(1 << (fl % 8)); }
      bool HasFlag(uint16 fl)   { return (Flags[fl/8] & (1 << (fl % 8))) != 0; }
			uint8 Flags[(GF_LAST/8)+1];
      String & Describe(); 
  };

class TRegion: public Resource
  {
    public:
      TRegion() : Resource (T_TREGION) { }
      int8 Depth, Size; 
      rID Walls, Floor, Door;
      int8 MTypes[4];
      rID Furnishings[6];
      uint32 RoomTypes; 
      uint8 sx,sy; hText Grid;
      void SetFlag(uint16 fl)   { Flags[fl/8] |=  (1 << (fl % 8)); }
      void UnsetFlag(uint16 fl) { Flags[fl/8] &= ~(1 << (fl % 8)); }
      bool HasFlag(uint16 fl)   { return (Flags[fl/8] & (1 << (fl % 8))) != 0; }
			uint8 Flags[(RF_LAST/8)+1];
  };

class TTerrain: public Resource
  {
    public:
      TTerrain() : Resource(T_TTERRAIN) {  }
      Glyph Image;
      int8 MoveMod;
      int8 Penalty;
      int8 Material;
      rID eID; int8 SpecChance;
      void SetFlag(uint16 fl)   { Flags[fl/8] |=  (1 << (fl % 8)); }
      void UnsetFlag(uint16 fl) { Flags[fl/8] &= ~(1 << (fl % 8)); }

      bool HasFlag(uint16 fl)   { return (Flags[fl/8] & (1 << (fl % 8))) != 0; }
			uint8 Flags[(TF_LAST/8)+1];
      inline bool TerrainHasFlag(uint16 fl) { return HasFlag(fl); } 
  };

class TText: public Resource
  {
    public:
      TText() : Resource(T_TTEXT) { }
      int8 dsfdsfs;
  };

class TVariable: public Resource
  {
    public:
      TVariable() : Resource(T_TVARIABLE) { }
      hData Location;
  };

class TTemplate: public Resource
  {
    public:
      TTemplate() : Resource(T_TTEMPLATE) { }
      void Dump();
      Glyph NewImage; uint16 TType; int8 DmgMod;
      MVal HitDice, Hit, Def, CR, Mov, Spd, Weight, Size,
           Power, CasterLev, Arm;
       
      MVal Attr[7]; /* ww: would cause ForMType to be overwritten */
      Status Stati[NUM_TMON_STATI]; 
      int32 ForMType, AddMType;
      uint16 NewFeats[16];
      TAttack NewAttk[16];
      uint8 AddFlags[(M_LAST/8)+1],
             SubFlags[(M_LAST/8)+1],
             Flags[((-TMF_LAST)/8)+1];
      void SetFlag(int16 fl)   { ASSERT(abs(fl) < abs(TMF_LAST)); 
                                 if (fl < 0) fl = -fl;
                                  Flags[fl/8] |=  (1 << (fl % 8)); }
      void UnsetFlag(int16 fl) { ASSERT(abs(fl) < abs(TMF_LAST)); 
                                 if (fl < 0) fl = -fl;
                                  Flags[fl/8] &= ~(1 << (fl % 8)); }
      bool HasFlag(int16 fl)   { ASSERT(abs(fl) < abs(TMF_LAST)); 
                                 if (fl < 0) fl = -fl;
                                 return (Flags[fl/8] & (1 << (fl % 8))) != 0; }
      bool AddsFlag(int16 fl)   { ASSERT(fl >= 0 && fl < M_LAST);
                                  return (AddFlags[fl/8] & (1 << (fl % 8))) != 0; }
      bool SubsFlag(int16 fl)   { ASSERT(fl >= 0 && fl < M_LAST);
                                  return (SubFlags[fl/8] & (1 << (fl % 8))) != 0; }
      uint32 AddImm, SubImm;
      uint16 AddRes, SubRes;
      bool HasFeat(int16 ft) {
        for(int16 i=0;i!=16 && NewFeats[i];i++)
          if (NewFeats[i] == ft)
            return true;
        return false;
        }
      bool HasAttk(int8 i) { return NewAttk[0].AType == i ||
                                    NewAttk[1].AType == i ||
                                    NewAttk[2].AType == i ||
                                    NewAttk[3].AType == i ||
                                    NewAttk[4].AType == i ||
                                    NewAttk[5].AType == i ||
                                    NewAttk[6].AType == i ||
                                    NewAttk[7].AType == i ||
                                    NewAttk[8].AType == i ||
                                    NewAttk[9].AType == i ||
                                    NewAttk[10].AType == i ||
                                    NewAttk[11].AType == i; }
      TAttack* GetNewAttk(int8 i) 
      { if (NewAttk[0].AType == i) return &NewAttk[0];
        if (NewAttk[1].AType == i) return &NewAttk[1];
        if (NewAttk[2].AType == i) return &NewAttk[2];
        if (NewAttk[3].AType == i) return &NewAttk[3];
        if (NewAttk[4].AType == i) return &NewAttk[4];
        if (NewAttk[5].AType == i) return &NewAttk[5];
        if (NewAttk[6].AType == i) return &NewAttk[6];
        if (NewAttk[7].AType == i) return &NewAttk[7];
        if (NewAttk[8].AType == i) return &NewAttk[8];
        if (NewAttk[9].AType == i) return &NewAttk[9];
        if (NewAttk[10].AType == i) return &NewAttk[10];
        if (NewAttk[11].AType == i) return &NewAttk[11];
        return NULL; } 
    bool GainStati(uint8 Nature, int16 Val = 0, int16 Mag = 0, rID rr = 0)
    {
      for (int i = 0; i<NUM_TMON_STATI; i++) {
        if (Stati[i].Nature == 0) {
          Stati[i].Nature = Nature;
          Stati[i].Val = Val;
          Stati[i].Mag = Mag;
          Stati[i].Duration = -1; 
          Stati[i].eID = rr; 
          Stati[i].Source = SS_BODY; 
          return true; 
        } 
      } 
      return false; 
    } 

  };

class TFlavor: public Resource
  {
    public:
      TFlavor() : Resource(T_TFLAVOR) { }
      int8 IType, Weight, Material, Color;
  };
  
class TBehaviour: public Resource
  {
    public:
      TBehaviour() : Resource(T_TBEHAVIOUR) { }
      rID spID; /* Spell-specific behaviour */
      uint32 Conditions;
      void SetFlag(uint16 fl)   { Flags[fl/8] |=  (1 << (fl % 8)); }
      void UnsetFlag(uint16 fl) { Flags[fl/8] &= ~(1 << (fl % 8)); }
      bool HasFlag(uint16 fl)   { return (Flags[fl/8] & (1 << (fl % 8))) != 0; }
			uint8 Flags[(BF_LAST/8)+1];
	};
	
struct EncPart
  {
    uint32 Flags;
    uint8 Weight;
    uint8 Chance;
    uint8 minCR;
    Dice  Amt;
    hCode Condition;
    rID xID;
    rID xID2;
  };
    
	
class TEncounter: public Resource
  {
    public:
      TEncounter() : Resource(T_TENCOUNTER) { }
      uint32 Terrain;
      int16 Weight, minCR, maxCR, Freak, Depth, Align;
      EncPart Parts[MAX_PARTS];
      void SetFlag(uint16 fl)   { Flags[fl/8] |=  (1 << (fl % 8)); }
      void UnsetFlag(uint16 fl) { Flags[fl/8] &= ~(1 << (fl % 8)); }
      bool HasFlag(uint16 fl)   { return (Flags[fl/8] & (1 << (fl % 8))) != 0; }
			uint8 Flags[(NF_LAST/8)+1];
  };

class Module : public Object
  {
    friend class Magic;
    friend class VMachine;
    friend Annotation* Resource::Annot(int32 i);
    friend Annotation* Resource::NewAnnot(int8 at,int32 *num, int32 *num2);
    friend String* Resource::GetMessages(int16 ev);
    friend String & Resource::RandMessage(int16 ev);
    friend EvReturn Resource::Event(EventInfo &e, rID xID, int16 context);

    ARCHIVE_CLASS(Module,Object,r)
      int32 i;
      memset(GetResourceCache,0,sizeof(GetResourceCache));
      memset(GetResourceIndex,0,sizeof(GetResourceIndex));
      if (r.Saving())
        for (i=0;i!=szTextSeg;i++)
          *(((char*)QTextSeg)+i) = ~(*(QTextSeg+i));
      r.Block((void**)(&QMon),sizeof(TMonster)  *szMon);
      r.Block((void**)(&QItm),sizeof(TItem)     *szItm);
      r.Block((void**)(&QFea),sizeof(TFeature)  *szFea);
      r.Block((void**)(&QEff),sizeof(TEffect)   *szEff);
      r.Block((void**)(&QArt),sizeof(TArtifact) *szArt);
      r.Block((void**)(&QQue),sizeof(TQuest)    *szQue);
      r.Block((void**)(&QDgn),sizeof(TDungeon)  *szDgn);
      r.Block((void**)(&QRou),sizeof(TRoutine)  *szRou);
      r.Block((void**)(&QNPC),sizeof(TNPC)      *szNPC);
      r.Block((void**)(&QCla),sizeof(TClass)    *szCla);
      r.Block((void**)(&QRac),sizeof(TRace)     *szRac);
      r.Block((void**)(&QDom),sizeof(TDomain)   *szDom);
      r.Block((void**)(&QGod),sizeof(TGod)      *szGod);
      r.Block((void**)(&QReg),sizeof(TRegion)   *szReg);
      r.Block((void**)(&QTer),sizeof(TTerrain)  *szTer);
      r.Block((void**)(&QTxt),sizeof(TText)     *szTxt);
      r.Block((void**)(&QVar),sizeof(TVariable) *szVar);
      r.Block((void**)(&QTem),sizeof(TTemplate) *szTem);
      r.Block((void**)(&QFla),sizeof(TFlavor)   *szFla);
      r.Block((void**)(&QBev),sizeof(TBehaviour)*szBev);
      r.Block((void**)(&QEnc),sizeof(TEncounter)*szEnc);
      Annotations.Serialize(r);
      Symbols.Serialize(r);
      r.Block((void**)(&QTextSeg), szTextSeg);
      r.Block((void**)(&QCodeSeg), szCodeSeg * sizeof(VCode));
      if (r.Loading())
        for (i=0;i!=szTextSeg;i++)
          *(((char*)QTextSeg)+i) = ~(*(QTextSeg+i));
    END_ARCHIVE
    public:
		Module() : Object(T_MODULE) { 
      /* Annotation #0 is unused, because we use a 0
         for the annotation-chain terminator. */
      Annotations.NewItem();
      memset(GetResourceCache,0,sizeof(GetResourceCache));
      memset(GetResourceIndex,0,sizeof(GetResourceIndex));
      }
      /* friend Game; */
    ~Module();
    virtual bool inGroup(hObj h);
    #define GET_RESOURCE_CACHE_SIZE 4096
    Resource * GetResourceCache[GET_RESOURCE_CACHE_SIZE];
    rID        GetResourceIndex[GET_RESOURCE_CACHE_SIZE];
    Resource* __GetResource(rID r);
    Resource* GetResource(rID r);
    rID FindResource(const char*);

    inline Resource* GetResource(const char* name)
      { return GetResource(FindResource(name)); }
    const char* GetText(hText ht)
      { return QTextSeg + ht; }
    rID RandomResource(uint8 RType, int8 Level, int8 Range);
    uint32 GetMemoryPtr(rID xID, int8 pn);
    hText Name, FName; int16 Slot;
    //protected:
    /* Resource IDs are *always* given in this order:
       Monsters  = first_rID + num
       Items     = first_rID + szMon + num
       Features  = first_rID + szMon + szItm + num
       Effects   = first_rID + szMon + szItm + szFea + num
       Artifacts = first_rID + szMon +  ...  + szEff + num
       Quests    = first_rID + szMon +  ...  + szArt + num
       Dungeons  = first_rID + szMon +  ...  + szQue + num
       Routines  = first_rID + szMon +  ...  + szDgn + num
       NPCs      = first_rID + szMon +  ...  + szRou + num
       Classes   = first_rID + szMon +  ...  + szNPC + num
       Races     = first_rID + szMon +  ...  + szCla + num
       Domains   = first_rID + szMon +  ...  + szRac + num
       Gods      = first_rID + szMon +  ...  + szDom + num
       Regions   = first_rID + szMon +  ...  + szGod + num
       Terrains
       Texts
       Variables
       Templates
       Flavors
       Behaviours
       Encounters
      */
      TMonster   *QMon;
      TItem      *QItm;
      TFeature   *QFea;
      TEffect    *QEff;
      TArtifact  *QArt;
      TQuest     *QQue;
      TDungeon   *QDgn;
      TRoutine   *QRou;
      TNPC       *QNPC;
      TClass     *QCla;
      TRace      *QRac;
      TDomain    *QDom;
      TGod       *QGod;
      TRegion    *QReg;
      TTerrain   *QTer;
      TText      *QTxt;
      TVariable  *QVar;
      TTemplate  *QTem;
      TFlavor    *QFla;
      TBehaviour *QBev;
      TEncounter *QEnc;
      
      const char *QTextSeg;
      VCode      *QCodeSeg;
      int32      szTextSeg, 
                 szDataSeg,
                 szCodeSeg;  
      OArray<Annotation,ANNOT_INITIAL_SIZE,20> Annotations;
      OArray<DebugInfo,1000,1000> Symbols;
      void AddDebugInfo(int32 ID, Binding *b);
      int16     szMon, szItm, szFea, szEff, szArt, szQue,
        szDgn, szRou, szNPC, szCla, szRac, szDom, szGod, 
        szReg, szTer, szTxt, szVar, szTem, szFla, szBev,
        szEnc;
      int32     TurnLastUsed;
      
      
      rID MonsterID(uint16 num)
        { return (0x01000000 * (Slot+1)) + num; }
      rID ItemID(uint16 num)
        { return (0x01000000 * (Slot+1)) + szMon + num; }
      rID FeatureID(uint16 num)
        { return (0x01000000 * (Slot+1)) + szMon + szItm + num; }
      rID EffectID(uint16 num)
        { return (0x01000000 * (Slot+1)) + szMon + szItm + szFea + num; }
      rID ArtifactID(uint16 num)
        { return (0x01000000 * (Slot+1)) + szMon + szItm + szFea + szEff
          + num; }
      rID QuestID(uint16 num)
        { return (0x01000000 * (Slot+1)) + szMon + szItm + szFea + szEff
          + szArt + num; }
      rID DungeonID(uint16 num)
        { return (0x01000000 * (Slot+1)) + szMon + szItm + szFea + szEff
          + szArt + szQue + num; }
      rID RoutineID(uint16 num)
        { return (0x01000000 * (Slot+1)) + szMon + szItm + szFea + szEff
          + szArt + szQue + szDgn + num; }
      rID NPCID(uint16 num)
        { return (0x01000000 * (Slot+1)) + szMon + szItm + szFea + szEff
          + szArt + szQue + szDgn + szRou + num; }
      rID ClassID(uint16 num)
        { return (0x01000000 * (Slot+1)) + szMon + szItm + szFea + szEff
          + szArt + szQue + szDgn + szRou + szNPC + num; }
      rID RaceID(uint16 num)
        { return (0x01000000 * (Slot+1)) + szMon + szItm + szFea + szEff
          + szArt + szQue + szDgn + szRou + szNPC + szCla +
          num; }
      rID DomainID(uint16 num)
        { return (0x01000000 * (Slot+1)) + szMon + szItm + szFea + szEff
          + szArt + szQue + szDgn + szRou + szNPC + szCla +
          szRac + num; }
      rID GodID(uint16 num)
        { return (0x01000000 * (Slot+1)) + szMon + szItm + szFea + szEff
          + szArt + szQue + szDgn + szRou + szNPC + szCla +
          szRac + szDom + num; }
      rID RegionID(uint16 num)
        { return (0x01000000 * (Slot+1)) + szMon + szItm + szFea + szEff
          + szArt + szQue + szDgn + szRou + szNPC + szCla +
          szRac + szDom + szGod + num; }
      rID TerrainID(uint16 num)
        { return (0x01000000 * (Slot+1)) + szMon + szItm + szFea + szEff
          + szArt + szQue + szDgn + szRou + szNPC + szCla +
          szRac + szDom + szGod + szReg + num; }
      rID TextID(uint16 num)
        { return (0x01000000 * (Slot+1)) + szMon + szItm + szFea + szEff
          + szArt + szQue + szDgn + szRou + szNPC + szCla +
          szRac + szDom + szGod + szReg + szTer + num; }
      rID VariableID(uint16 num)
        { return (0x01000000 * (Slot+1)) + szMon + szItm + szFea + szEff
          + szArt + szQue + szDgn + szRou + szNPC + szCla +
          szRac + szDom + szGod + szReg + szTer + szTxt +
          num; }
      rID TemplateID(uint16 num)
        { return (0x01000000 * (Slot+1)) + szMon + szItm + szFea + szEff
          + szArt + szQue + szDgn + szRou + szNPC + szCla +
          szRac + szDom + szGod + szReg + szTer + szTxt +
          szVar + num; }
      rID FlavorID(uint16 num)
        { return (0x01000000 * (Slot+1)) + szMon + szItm + szFea + szEff
          + szArt + szQue + szDgn + szRou + szNPC + szCla +
          szRac + szDom + szGod + szReg + szTer + szTxt +
          szVar + szTem + num; }
      rID BehaviourID(uint16 num)
        { return (0x01000000 * (Slot+1)) + szMon + szItm + szFea + szEff
          + szArt + szQue + szDgn + szRou + szNPC + szCla +
          szRac + szDom + szGod + szReg + szTer + szTxt +
          szVar + szTem + szFla + num; }
      rID EncounterID(uint16 num)
        { return (0x01000000 * (Slot+1)) + szMon + szItm + szFea + szEff
          + szArt + szQue + szDgn + szRou + szNPC + szCla +
          szRac + szDom + szGod + szReg + szTer + szTxt +
          szVar + szTem + szFla + szBev + num; }


      int16 SpellNum(Resource *r);
      int16 GodNum(Resource *r);
      int16 TemplateNum(Resource *r);
      int16 NumResources()
        { return szMon + szItm + szFea + szEff + szArt + szQue
            + szDgn + szRou + szNPC + szCla + szRac + szDom +
            szGod + szReg + szTer + szTxt + szVar + szTem + 
            szFla + szBev + szEnc; }



  };
extern bool QuestMode;



struct LimboEntry
  {
    hObj h, Target;
    uint8 x,y;
    rID  mID;
    int8 Depth, OldDepth;
    uint32 Arrival;
    String Message;
  };

struct ModuleRecord
  {
    uint8 Slot;
    hObj  hMod;
    char  FName[1024];
  };

struct __FindCache
  {
    rID   xID;
    char  str[32];
  };


class Game : public Object
  {
    friend class Thing;
    friend class Magic;
    friend class VMachine;
    friend Annotation* Resource::Annot(int32 i);
    friend Annotation* Resource::NewAnnot(int8 at,int32 *num, int32 *num2);
    friend String* Resource::GetMessages(int16 ev);
    friend String & Resource::RandMessage(int16 ev);
    friend EvReturn Resource::Event(EventInfo &e, rID xID, int16 context);
    friend int32 VMachine::Execute(EventInfo *e, rID xID, hCode CP);
    friend const char* __XPrint(Player *POV, const char *msg,va_list args);
    ARCHIVE_CLASS(Game,Object,r)
      int16 i;
      for(i=0;i!=MAX_DUNGEONS;i++)
        if (DungeonLevels[i])
          r.Block((void**)&(DungeonLevels[i]),sizeof(hObj)*(DungeonSize[i]+1));
      for(i=0;i!=MAX_MODULES;i++)
        if (MDataSeg[i])
          r.Block((void**)&(MDataSeg[i]),MDataSegSize[i]);
      Limbo.Serialize(r);      
      ModFiles.Serialize(r);
      SaveFile.Serialize(r);
    END_ARCHIVE
    public:
      int32 ccHasEffStati,
            ccHasValStati,
            ccHasNatStati,
            ccHasStatiTrue,
            ccHasStatiFalse,
            ccHSPerceive,
            ccHSMonAI,
            ccHSCalcVal,
            inPerceive,
            inChooseAct,
            inCalcVal,
            ccStatiNat[256],
            ccStatiVal[256];
    public: /* Debugging Hack; 'private' later */
      uint32 Turn, Day; String SaveFile;
      static Module *Modules[MAX_MODULES];
      char   *MDataSeg[MAX_MODULES];
      uint32 MDataSegSize[MAX_MODULES];
      hObj m[4], p[4], Timestopper;
      bool PlayMode, doSave, doLoad, doAutoSave, doQuit;
      int8 Difficulty;
      static Thing *DestroyQueue[20480];
      static uint16  DestroyCount;
      static Thing *cDestroyQueue[20480];
      static uint16  cDestroyCount;
      rID   DungeonID[MAX_DUNGEONS];
      int16 DungeonSize[MAX_DUNGEONS];
      hObj  *DungeonLevels[MAX_DUNGEONS];
      OArray<LimboEntry,20,10> Limbo;
      OArray<ModuleRecord,5,5> ModFiles;
      __FindCache FindCache[128];
      int16 szFindCache;

    public:
      VMachine VM;
      int16 ItemGenNum, BarrierCount;
      Game();
      bool InPlay()      { return PlayMode; }
      void SetSaveFlag()     { doSave = true; }
      void SetQuitFlag()     { doQuit = true; }
      bool getQuitFlag()     { return doQuit; }
      void SetAutoSaveFlag() { doAutoSave = true; }
      uint32 GetTurn()   { return Turn; }
      int8 NumPlayers()  { return 1; }
      void TitleScreen();
      void StartMenu();
      void CheckConsistency();
      void MonsterEvaluation();
      void MonsterEvaluationCR();
      void WeaponEvaluation();
      void GenerateRarityTable();
      String & CompileStatistics();
      void ListItemsByLevel();
      void MemoryStats();
      void WriteHTMLHelp();
      void NewGame(rID mID, bool reincarnate);
      bool LoadGame(bool backup);
      bool SaveGame(Player &p);
      bool LoadModules();
      void SaveModule(int16 mn);
      void Play();
      void MultiPlay();
      void Cleanup();
      void EnterLimbo(hObj h, uint8 x, uint8 y, rID mID, 
        int8 Depth, int8 OldDepth, int32 Arrival, const char* Message);
      void LimboCheck(Map *m);
      int16 Opt(int16 op);
      Map* GetDungeonMap(rID dID, int16 Depth, Player *p,Map*TownLevel=NULL);
      inline void StopTime(Creature *caster);
      bool isTimeStopped() { return !(Timestopper == 0); }
      Resource *Get(rID r);
      rID Find(const char*);
      const char*GetName(rID xID)
        { return Modules[(xID >> 24)-1]->GetText(Get(xID)->Name); }
      const char*GetDesc(rID xID)
        { return Modules[(xID >> 24)-1]->GetText(Get(xID)->Desc); }
      const char*GetText(rID xID,hText Text)
        { return Modules[(xID >> 24)-1]->GetText(Text); }
      Player *GetPlayer(int8 n);

      rID    SpellID(uint16 sp);
      inline int16 SpellNum (rID sID);
      inline int16 SpellNum (Resource *r);
      uint16 LastSpell();
      rID    GodID(uint16 sp);
      inline int16 GodNum (rID sID);
      inline int16 GodNum (Resource *r);
      uint16 LastGod();
      rID    TemplateID(uint16 sp);
      inline int16 TemplateNum (rID sID);
      inline int16 TemplateNum (Resource *r);
      uint16 LastTemplate();
      
      rID RandomResource(uint8 typ, int8 Level=-1, int8 Range=-1);
      rID GetItemID(int16 Purpose, int8 minlev, int8 maxlev, int8 IType=-1);
      rID GetMonID(int16 Purpose, int8 minlev, int8 maxlev, int8 Depth, int32 MType=-1);
      rID GetEffectID(int16 Purpose, int8 minlev, int8 maxlev, int8 Source=0);
      rID GetEncounterID(int16 CR, uint32 Types, uint32 Terrain);
      rID GetMapID(int16 Purpose, uint8 depth, int8 MType=-1) { return 0; }
      rID GetTempID(uint16 Types, rID mID, int8 maxCR);
      void SetFlavors();
      void* GetMemory(rID xID, Player *p);
      void DumpCode();

      String BuildText(EventInfo &e, rID tID);
      String RecursiveParse(EventInfo &e, rID tID, int32 *t, int16 len);

      #ifndef NO_COMP
      bool ResourceCompiler();
      void CountResources();
      void ComposeMap();
      #endif

  };

inline int16 Game::SpellNum (rID sID)        { return Modules[0]->SpellNum(TEFF(sID)); }
inline int16 Game::SpellNum (Resource *r)    { return Modules[0]->SpellNum(r); }
inline int16 Game::GodNum (rID sID)          { return Modules[0]->GodNum(TEFF(sID)); }
inline int16 Game::GodNum (Resource *r)      { return Modules[0]->GodNum(r); }
inline int16 Game::TemplateNum (rID sID)     { return Modules[0]->TemplateNum(TEFF(sID)); }
inline int16 Game::TemplateNum (Resource *r) { return Modules[0]->TemplateNum(r); }

struct MonMem
  {
    unsigned int Battles   :8;
    unsigned int Deaths    :8;
    unsigned int Kills     :8;
    unsigned int pKills    :8;
    unsigned int Attacks   :9;
    unsigned int Resists   :8;
    unsigned int Immune    :16;
    unsigned int Seen      :1;
    unsigned int Fought    :1;
    unsigned int Feats     :16;
    unsigned int Flags     :5;
  };

struct ItemMem
  {
    unsigned int Known      :1;
    unsigned int ProfLevel  :3;
    unsigned int Tried      :1;
    unsigned int Mastered   :1;
    unsigned int Unused     :2;
  };

struct EffMem
  {
    unsigned int FlavorID  :32;
    unsigned int PFlavorID :32;
    unsigned int Known     :1;
    unsigned int Tried     :1;
    unsigned int PKnown    :1;
    unsigned int PTried    :1;
  };

struct RegMem
  {
    unsigned int Seen;
  };
