/* This file generated by the resource compiler -- do not modify! */

#define DISPATCH



void VMachine::CallMemberFunc(int16 funcid, hObj h, int8 n) {
    static Object *t;
    static String str;

    switch(funcid) {
    case 0:
        VERIFY(h,T_OBJECT,"Name")
        ASSERT(REGS(63) >= 1)
        GETSTR(-1) = oObject(h)->Name((int16)STACK(1));
        return;
    case 1:
        VERIFY(h,T_OBJECT,"Describe")
        ASSERT(REGS(63) >= 1)
        GETSTR(-1) = oObject(h)->Describe(oPlayer(STACK(1)));
        return;
    case 2:
        VERIFY(h,T_MAP,"InBounds")
        ASSERT(REGS(63) >= 2)
        REGS(n) = oMap(h)->InBounds((int16)STACK(1), (int16)STACK(2));
        return;
    case 3:
        VERIFY(h,T_MAP,"GlyphAt")
        ASSERT(REGS(63) >= 2)
        REGS(n) = oMap(h)->GlyphAt((int16)STACK(1), (int16)STACK(2));
        return;
    case 4:
        VERIFY(h,T_MAP,"FlagsAt")
        ASSERT(REGS(63) >= 2)
        REGS(n) = oMap(h)->FlagsAt((int16)STACK(1), (int16)STACK(2));
        return;
    case 5:
        VERIFY(h,T_MAP,"SolidAt")
        ASSERT(REGS(63) >= 2)
        REGS(n) = oMap(h)->SolidAt((int16)STACK(1), (int16)STACK(2));
        return;
    case 6:
        VERIFY(h,T_MAP,"TreeAt")
        ASSERT(REGS(63) >= 2)
        REGS(n) = oMap(h)->TreeAt((int16)STACK(1), (int16)STACK(2));
        return;
    case 7:
        VERIFY(h,T_MAP,"FallAt")
        ASSERT(REGS(63) >= 2)
        REGS(n) = oMap(h)->FallAt((int16)STACK(1), (int16)STACK(2));
        return;
    case 8:
        VERIFY(h,T_MAP,"OpaqueAt")
        ASSERT(REGS(63) >= 2)
        REGS(n) = oMap(h)->OpaqueAt((int16)STACK(1), (int16)STACK(2));
        return;
    case 9:
        VERIFY(h,T_MAP,"LightAt")
        ASSERT(REGS(63) >= 2)
        REGS(n) = oMap(h)->LightAt((int16)STACK(1), (int16)STACK(2));
        return;
    case 10:
        VERIFY(h,T_MAP,"BrightAt")
        ASSERT(REGS(63) >= 2)
        REGS(n) = oMap(h)->BrightAt((int16)STACK(1), (int16)STACK(2));
        return;
    case 11:
        VERIFY(h,T_MAP,"RegionAt")
        ASSERT(REGS(63) >= 2)
        REGS(n) = oMap(h)->RegionAt((int16)STACK(1), (int16)STACK(2));
        return;
    case 12:
        VERIFY(h,T_MAP,"TerrainAt")
        ASSERT(REGS(63) >= 2)
        REGS(n) = oMap(h)->TerrainAt((int16)STACK(1), (int16)STACK(2));
        return;
    case 13:
        VERIFY(h,T_MAP,"SizeX")
        ASSERT(REGS(63) >= 0)
        REGS(n) = oMap(h)->SizeX();
        return;
    case 14:
        VERIFY(h,T_MAP,"SizeY")
        ASSERT(REGS(63) >= 0)
        REGS(n) = oMap(h)->SizeY();
        return;
    case 15:
        VERIFY(h,T_MAP,"FirstAt")
        ASSERT(REGS(63) >= 2)
        t = oMap(h)->FirstAt((int16)STACK(1), (int16)STACK(2));
        REGS(n) = t ? t->myHandle : 0;
        return;
    case 16:
        VERIFY(h,T_MAP,"NextAt")
        ASSERT(REGS(63) >= 2)
        t = oMap(h)->NextAt((int16)STACK(1), (int16)STACK(2));
        REGS(n) = t ? t->myHandle : 0;
        return;
    case 17:
        VERIFY(h,T_MAP,"MultiAt")
        ASSERT(REGS(63) >= 2)
        REGS(n) = oMap(h)->MultiAt((int16)STACK(1), (int16)STACK(2));
        return;
    case 18:
        VERIFY(h,T_MAP,"FCreatureAt")
        ASSERT(REGS(63) >= 2)
        t = oMap(h)->FCreatureAt((int16)STACK(1), (int16)STACK(2));
        REGS(n) = t ? t->myHandle : 0;
        return;
    case 19:
        VERIFY(h,T_MAP,"NCreatureAt")
        ASSERT(REGS(63) >= 2)
        t = oMap(h)->NCreatureAt((int16)STACK(1), (int16)STACK(2));
        REGS(n) = t ? t->myHandle : 0;
        return;
    case 20:
        VERIFY(h,T_MAP,"MCreatureAt")
        ASSERT(REGS(63) >= 2)
        REGS(n) = oMap(h)->MCreatureAt((int16)STACK(1), (int16)STACK(2));
        return;
    case 21:
        VERIFY(h,T_MAP,"FItemAt")
        ASSERT(REGS(63) >= 2)
        t = oMap(h)->FItemAt((int16)STACK(1), (int16)STACK(2));
        REGS(n) = t ? t->myHandle : 0;
        return;
    case 22:
        VERIFY(h,T_MAP,"NItemAt")
        ASSERT(REGS(63) >= 2)
        t = oMap(h)->NItemAt((int16)STACK(1), (int16)STACK(2));
        REGS(n) = t ? t->myHandle : 0;
        return;
    case 23:
        VERIFY(h,T_MAP,"MItemAt")
        ASSERT(REGS(63) >= 2)
        REGS(n) = oMap(h)->MItemAt((int16)STACK(1), (int16)STACK(2));
        return;
    case 24:
        VERIFY(h,T_MAP,"FFeatureAt")
        ASSERT(REGS(63) >= 2)
        t = oMap(h)->FFeatureAt((int16)STACK(1), (int16)STACK(2));
        REGS(n) = t ? t->myHandle : 0;
        return;
    case 25:
        VERIFY(h,T_MAP,"NFeatureAt")
        ASSERT(REGS(63) >= 2)
        t = oMap(h)->NFeatureAt((int16)STACK(1), (int16)STACK(2));
        REGS(n) = t ? t->myHandle : 0;
        return;
    case 26:
        VERIFY(h,T_MAP,"MFeatureAt")
        ASSERT(REGS(63) >= 2)
        REGS(n) = oMap(h)->MFeatureAt((int16)STACK(1), (int16)STACK(2));
        return;
    case 27:
        VERIFY(h,T_MAP,"FDoorAt")
        ASSERT(REGS(63) >= 2)
        t = oMap(h)->FDoorAt((int16)STACK(1), (int16)STACK(2));
        REGS(n) = t ? t->myHandle : 0;
        return;
    case 28:
        VERIFY(h,T_MAP,"NDoorAt")
        ASSERT(REGS(63) >= 2)
        t = oMap(h)->NDoorAt((int16)STACK(1), (int16)STACK(2));
        REGS(n) = t ? t->myHandle : 0;
        return;
    case 29:
        VERIFY(h,T_MAP,"MDoorAt")
        ASSERT(REGS(63) >= 2)
        REGS(n) = oMap(h)->MDoorAt((int16)STACK(1), (int16)STACK(2));
        return;
    case 30:
        VERIFY(h,T_MAP,"FTrapAt")
        ASSERT(REGS(63) >= 2)
        t = oMap(h)->FTrapAt((int16)STACK(1), (int16)STACK(2));
        REGS(n) = t ? t->myHandle : 0;
        return;
    case 31:
        VERIFY(h,T_MAP,"NTrapAt")
        ASSERT(REGS(63) >= 2)
        t = oMap(h)->NTrapAt((int16)STACK(1), (int16)STACK(2));
        REGS(n) = t ? t->myHandle : 0;
        return;
    case 32:
        VERIFY(h,T_MAP,"MTrapAt")
        ASSERT(REGS(63) >= 2)
        REGS(n) = oMap(h)->MTrapAt((int16)STACK(1), (int16)STACK(2));
        return;
    case 33:
        VERIFY(h,T_MAP,"FChestAt")
        ASSERT(REGS(63) >= 2)
        t = oMap(h)->FChestAt((int16)STACK(1), (int16)STACK(2));
        REGS(n) = t ? t->myHandle : 0;
        return;
    case 34:
        VERIFY(h,T_MAP,"NChestAt")
        ASSERT(REGS(63) >= 2)
        t = oMap(h)->NChestAt((int16)STACK(1), (int16)STACK(2));
        REGS(n) = t ? t->myHandle : 0;
        return;
    case 35:
        VERIFY(h,T_MAP,"MChestAt")
        ASSERT(REGS(63) >= 2)
        REGS(n) = oMap(h)->MChestAt((int16)STACK(1), (int16)STACK(2));
        return;
    case 36:
        VERIFY(h,T_MAP,"FirstThing")
        ASSERT(REGS(63) >= 0)
        t = oMap(h)->FirstThing();
        REGS(n) = t ? t->myHandle : 0;
        return;
    case 37:
        VERIFY(h,T_MAP,"NextThing")
        ASSERT(REGS(63) >= 0)
        t = oMap(h)->NextThing();
        REGS(n) = t ? t->myHandle : 0;
        return;
    case 38:
        VERIFY(h,T_MAP,"WriteAt")
        ASSERT(REGS(63) >= 7)
        oMap(h)->WriteAt(CAST_RECT(STACK(1)), (int16)STACK(2), (int16)STACK(3), STACK(4), STACK(5), STACK(6), STACK(7)!=0);
        return;
    case 39:
        VERIFY(h,T_MAP,"WriteBox")
        ASSERT(REGS(63) >= 2)
        oMap(h)->WriteBox(CAST_RECT(STACK(1)), STACK(2));
        return;
    case 40:
        VERIFY(h,T_MAP,"WriteRoom")
        ASSERT(REGS(63) >= 2)
        oMap(h)->WriteRoom(CAST_RECT(STACK(1)), STACK(2));
        return;
    case 41:
        VERIFY(h,T_MAP,"WriteCircle")
        ASSERT(REGS(63) >= 2)
        oMap(h)->WriteCircle(CAST_RECT(STACK(1)), STACK(2));
        return;
    case 42:
        VERIFY(h,T_MAP,"WriteWalls")
        ASSERT(REGS(63) >= 2)
        oMap(h)->WriteWalls(CAST_RECT(STACK(1)), STACK(2));
        return;
    case 43:
        VERIFY(h,T_MAP,"WriteLifeCave")
        ASSERT(REGS(63) >= 2)
        oMap(h)->WriteLifeCave(CAST_RECT(STACK(1)), STACK(2));
        return;
    case 44:
        VERIFY(h,T_MAP,"WriteCastle")
        ASSERT(REGS(63) >= 2)
        oMap(h)->WriteCastle(CAST_RECT(STACK(1)), STACK(2));
        return;
    case 45:
        VERIFY(h,T_MAP,"WriteRCavern")
        ASSERT(REGS(63) >= 2)
        oMap(h)->WriteRCavern(CAST_RECT(STACK(1)), STACK(2));
        return;
    case 46:
        VERIFY(h,T_MAP,"WriteOctagon")
        ASSERT(REGS(63) >= 2)
        oMap(h)->WriteOctagon(CAST_RECT(STACK(1)), STACK(2));
        return;
    case 47:
        VERIFY(h,T_MAP,"WriteDestroyed")
        ASSERT(REGS(63) >= 2)
        oMap(h)->WriteDestroyed(CAST_RECT(STACK(1)), STACK(2));
        return;
    case 48:
        VERIFY(h,T_MAP,"WriteMaze")
        ASSERT(REGS(63) >= 2)
        oMap(h)->WriteMaze(CAST_RECT(STACK(1)), STACK(2));
        return;
    case 49:
        VERIFY(h,T_MAP,"WriteCross")
        ASSERT(REGS(63) >= 2)
        oMap(h)->WriteCross(CAST_RECT(STACK(1)), STACK(2));
        return;
    case 50:
        VERIFY(h,T_MAP,"WriteMap")
        ASSERT(REGS(63) >= 2)
        oMap(h)->WriteMap(CAST_RECT(STACK(1)), STACK(2));
        return;
    case 51:
        VERIFY(h,T_MAP,"WriteBlobs")
        ASSERT(REGS(63) >= 3)
        oMap(h)->WriteBlobs(CAST_RECT(STACK(1)), STACK(2), STACK(3));
        return;
    case 52:
        VERIFY(h,T_MAP,"Generate")
        ASSERT(REGS(63) >= 4)
        oMap(h)->Generate(STACK(1), (int16)STACK(2), oMap(STACK(3)), (int8)STACK(4));
        return;
    case 53:
        VERIFY(h,T_MAP,"DrawPanel")
        ASSERT(REGS(63) >= 2)
        oMap(h)->DrawPanel((uint8)STACK(1), (uint8)STACK(2));
        return;
    case 54:
        VERIFY(h,T_MAP,"PopulatePanel")
        ASSERT(REGS(63) >= 2)
        oMap(h)->PopulatePanel(CAST_RECT(STACK(1)), (uint16)STACK(2));
        return;
    case 55:
        VERIFY(h,T_MAP,"Tunnel")
        ASSERT(REGS(63) >= 7)
        REGS(n) = oMap(h)->Tunnel((uint8)STACK(1), (uint8)STACK(2), (uint8)STACK(3), (uint8)STACK(4), (uint8)STACK(5), (int8)STACK(6), (int8)STACK(7));
        return;
    case 56:
        VERIFY(h,T_MAP,"MakeDoor")
        ASSERT(REGS(63) >= 3)
        oMap(h)->MakeDoor((uint8)STACK(1), (uint8)STACK(2), STACK(3));
        return;
    case 57:
        VERIFY(h,T_MAP,"FindOpenAreas")
        ASSERT(REGS(63) >= 2)
        REGS(n) = oMap(h)->FindOpenAreas(CAST_RECT(STACK(1)), (uint16)STACK(2));
        return;
    case 58:
        VERIFY(h,T_MAP,"SetGlyphAt")
        ASSERT(REGS(63) >= 3)
        oMap(h)->SetGlyphAt((int16)STACK(1), (int16)STACK(2), (uint16)STACK(3));
        return;
    case 59:
        VERIFY(h,T_MAP,"SetRegion")
        ASSERT(REGS(63) >= 2)
        oMap(h)->SetRegion(CAST_RECT(STACK(1)), STACK(2));
        return;
    case 60:
        VERIFY(h,T_MAP,"GetOpenXY")
        ASSERT(REGS(63) >= 0)
        REGS(n) = oMap(h)->GetOpenXY();
        return;
    case 61:
        VERIFY(h,T_MAP,"LineOfSight")
        ASSERT(REGS(63) >= 5)
        REGS(n) = oMap(h)->LineOfSight((int16)STACK(1), (int16)STACK(2), (int16)STACK(3), (int16)STACK(4), oCreature(STACK(5)));
        return;
    case 62:
        VERIFY(h,T_MAP,"Update")
        ASSERT(REGS(63) >= 2)
        oMap(h)->Update((int16)STACK(1), (int16)STACK(2));
        return;
    case 63:
        VERIFY(h,T_MAP,"VUpdate")
        ASSERT(REGS(63) >= 2)
        oMap(h)->VUpdate((int16)STACK(1), (int16)STACK(2));
        return;
    case 64:
        VERIFY(h,T_MAP,"MarkAsSeen")
        ASSERT(REGS(63) >= 4)
        oMap(h)->MarkAsSeen((int8)STACK(1), (int16)STACK(2), (int16)STACK(3), (int16)STACK(4));
        return;
    case 473:
        ASSERT(REGS(63) >= 4)
        REGS(n) = dist((int16)STACK(1), (int16)STACK(2), (int16)STACK(3), (int16)STACK(4));
        return;
    case 65:
        VERIFY(h,T_MAP,"NewField")
        ASSERT(REGS(63) >= 8)
        oMap(h)->NewField(STACK(1), (int16)STACK(2), (int16)STACK(3), (uint8)STACK(4), STACK(5), (int16)STACK(6), STACK(7), oCreature(STACK(8)));
        return;
    case 66:
        VERIFY(h,T_MAP,"FieldAt")
        ASSERT(REGS(63) >= 3)
        REGS(n) = oMap(h)->FieldAt((int16)STACK(1), (int16)STACK(2), STACK(3));
        return;
    case 67:
        VERIFY(h,T_MAP,"RemoveEffField")
        ASSERT(REGS(63) >= 1)
        oMap(h)->RemoveEffField(STACK(1));
        return;
    case 68:
        VERIFY(h,T_MAP,"RemoveFieldFrom")
        ASSERT(REGS(63) >= 1)
        oMap(h)->RemoveFieldFrom(STACK(1));
        return;
    case 69:
        VERIFY(h,T_MAP,"RemoveEffFieldFrom")
        ASSERT(REGS(63) >= 2)
        oMap(h)->RemoveEffFieldFrom(STACK(1), STACK(2));
        return;
    case 70:
        VERIFY(h,T_MAP,"DispelField")
        ASSERT(REGS(63) >= 5)
        REGS(n) = oMap(h)->DispelField((int16)STACK(1), (int16)STACK(2), STACK(3), STACK(4), (int16)STACK(5));
        return;
    case 71:
        VERIFY(h,T_MAP,"SetQueue")
        ASSERT(REGS(63) >= 1)
        oMap(h)->SetQueue((int16)STACK(1));
        return;
    case 72:
        VERIFY(h,T_MAP,"UnsetQueue")
        ASSERT(REGS(63) >= 1)
        oMap(h)->UnsetQueue((int16)STACK(1));
        return;
    case 73:
        VERIFY(h,T_MAP,"PrintQueue")
        ASSERT(REGS(63) >= 1)
        oMap(h)->PrintQueue((int16)STACK(1));
        return;
    case 74:
        VERIFY(h,T_MAP,"QueueNum")
        ASSERT(REGS(63) >= 0)
        REGS(n) = oMap(h)->QueueNum();
        return;
    case 75:
        VERIFY(h,T_MAP,"GetTerraDC")
        ASSERT(REGS(63) >= 2)
        REGS(n) = oMap(h)->GetTerraDC((int16)STACK(1), (int16)STACK(2));
        return;
    case 76:
        VERIFY(h,T_MAP,"GetTerraCreator")
        ASSERT(REGS(63) >= 2)
        t = oMap(h)->GetTerraCreator((int16)STACK(1), (int16)STACK(2));
        REGS(n) = t ? t->myHandle : 0;
        return;
    case 77:
        VERIFY(h,T_MAP,"GetTerraDType")
        ASSERT(REGS(63) >= 2)
        REGS(n) = oMap(h)->GetTerraDType((int16)STACK(1), (int16)STACK(2));
        return;
    case 78:
        VERIFY(h,T_MAP,"GetTerraDmg")
        ASSERT(REGS(63) >= 2)
        REGS(n) = oMap(h)->GetTerraDmg((int16)STACK(1), (int16)STACK(2));
        return;
    case 79:
        VERIFY(h,T_MAP,"RemoveTerra")
        ASSERT(REGS(63) >= 1)
        oMap(h)->RemoveTerra((int16)STACK(1));
        return;
    case 80:
        VERIFY(h,T_MAP,"RemoveTerraXY")
        ASSERT(REGS(63) >= 3)
        oMap(h)->RemoveTerraXY((int16)STACK(1), (int16)STACK(2), STACK(3));
        return;
    case 81:
        VERIFY(h,T_MAP,"WriteTerra")
        ASSERT(REGS(63) >= 3)
        oMap(h)->WriteTerra((int16)STACK(1), (int16)STACK(2), STACK(3));
        return;
    case 82:
        VERIFY(h,T_MAP,"MakeNoiseXY")
        ASSERT(REGS(63) >= 3)
        oMap(h)->MakeNoiseXY((int16)STACK(1), (int16)STACK(2), (int16)STACK(3));
        return;
    case 83:
        VERIFY(h,T_MAP,"GetEncounterCreature")
        ASSERT(REGS(63) >= 1)
        t = oMap(h)->GetEncounterCreature(STACK(1));
        REGS(n) = t ? t->myHandle : 0;
        return;
    case 84:
        VERIFY(h,T_MAP,"LineOfFire")
        ASSERT(REGS(63) >= 5)
        REGS(n) = oMap(h)->LineOfFire((int16)STACK(1), (int16)STACK(2), (int16)STACK(3), (int16)STACK(4), oCreature(STACK(5)));
        return;
    case 85:
        VERIFY(h,T_MAP,"enUniformGet")
        ASSERT(REGS(63) >= 1)
        REGS(n) = oMap(h)->enUniformGet(STACK(1));
        return;
    case 86:
        VERIFY(h,T_MAP,"enUniformAdd")
        ASSERT(REGS(63) >= 2)
        oMap(h)->enUniformAdd(STACK(1), STACK(2));
        return;
    case 87:
        VERIFY(h,T_MAP,"enAddMon")
        ASSERT(REGS(63) >= 1)
        oMap(h)->enAddMon(*pe);
        return;
    case 88:
        VERIFY(h,T_MAP,"enAddTemp")
        ASSERT(REGS(63) >= 2)
        oMap(h)->enAddTemp(*pe, STACK(2));
        return;
    case 89:
        VERIFY(h,T_MAP,"enAddMountTemp")
        ASSERT(REGS(63) >= 2)
        oMap(h)->enAddMountTemp(*pe, STACK(2));
        return;
    case 90:
        VERIFY(h,T_MAP,"enTemplateOk")
        ASSERT(REGS(63) >= 3)
        REGS(n) = oMap(h)->enTemplateOk(*pe, STACK(2), STACK(3)!=0);
        return;
    case 91:
        VERIFY(h,T_MAP,"enWarn")
        ASSERT(REGS(63) >= 1)
        oMap(h)->enWarn(GETSTR(STACK(1)),
                      VSTACK(2),VSTACK(3),VSTACK(4),VSTACK(5),VSTACK(6),VSTACK(7),VSTACK(8),VSTACK(9));
        return;
    case 92:
        VERIFY(h,T_MAP,"thEnGen")
        ASSERT(REGS(63) >= 4)
        REGS(n) = oMap(h)->thEnGen(STACK(1), STACK(2), (int8)STACK(3), (uint16)STACK(4));
        return;
    case 93:
        VERIFY(h,T_MAP,"thEnGenXY")
        ASSERT(REGS(63) >= 6)
        REGS(n) = oMap(h)->thEnGenXY(STACK(1), STACK(2), (int8)STACK(3), (uint16)STACK(4), (int16)STACK(5), (int16)STACK(6));
        return;
    case 94:
        VERIFY(h,T_MAP,"thEnGenSummXY")
        ASSERT(REGS(63) >= 7)
        REGS(n) = oMap(h)->thEnGenSummXY(STACK(1), STACK(2), (int8)STACK(3), (uint16)STACK(4), oCreature(STACK(5)), (int16)STACK(6), (int16)STACK(7));
        return;
    case 95:
        VERIFY(h,T_MAP,"thEnGenMon")
        ASSERT(REGS(63) >= 5)
        REGS(n) = oMap(h)->thEnGenMon(STACK(1), STACK(2), STACK(3), (int8)STACK(4), (uint16)STACK(5));
        return;
    case 96:
        VERIFY(h,T_MAP,"thEnGenMonXY")
        ASSERT(REGS(63) >= 7)
        REGS(n) = oMap(h)->thEnGenMonXY(STACK(1), STACK(2), STACK(3), (int8)STACK(4), (uint16)STACK(5), (int16)STACK(6), (int16)STACK(7));
        return;
    case 97:
        VERIFY(h,T_MAP,"thEnGenMType")
        ASSERT(REGS(63) >= 5)
        REGS(n) = oMap(h)->thEnGenMType(STACK(1), (int16)STACK(2), STACK(3), (int8)STACK(4), (uint16)STACK(5));
        return;
    case 98:
        VERIFY(h,T_MAP,"thEnGenMTypeXY")
        ASSERT(REGS(63) >= 7)
        REGS(n) = oMap(h)->thEnGenMTypeXY(STACK(1), (int16)STACK(2), STACK(3), (int8)STACK(4), (uint16)STACK(5), (int16)STACK(6), (int16)STACK(7));
        return;
    case 99:
        VERIFY(h,T_MAP,"thEnGenMonSummXY")
        ASSERT(REGS(63) >= 8)
        REGS(n) = oMap(h)->thEnGenMonSummXY(STACK(1), STACK(2), STACK(3), (int8)STACK(4), (uint16)STACK(5), oCreature(STACK(6)), (int16)STACK(7), (int16)STACK(8));
        return;
    case 100:
        VERIFY(h,T_MAP,"thEnGenMTypeSummXY")
        ASSERT(REGS(63) >= 8)
        REGS(n) = oMap(h)->thEnGenMTypeSummXY(STACK(1), (int16)STACK(2), STACK(3), (int8)STACK(4), (uint16)STACK(5), oCreature(STACK(6)), (int16)STACK(7), (int16)STACK(8));
        return;
    case 101:
        VERIFY(h,T_MAP,"rtEnGen")
        ASSERT(REGS(63) >= 5)
        REGS(n) = oMap(h)->rtEnGen(*pe, STACK(2), STACK(3), (int8)STACK(4), (uint16)STACK(5));
        return;
    case 102:
        VERIFY(h,T_OBJECT,"isType")
        ASSERT(REGS(63) >= 1)
        REGS(n) = oObject(h)->isType((int16)STACK(1));
        return;
    case 103:
        VERIFY(h,T_THING,"isCreature")
        ASSERT(REGS(63) >= 0)
        REGS(n) = oThing(h)->isCreature();
        return;
    case 104:
        VERIFY(h,T_THING,"isDead")
        ASSERT(REGS(63) >= 0)
        REGS(n) = oThing(h)->isDead();
        return;
    case 105:
        VERIFY(h,T_THING,"isPlayer")
        ASSERT(REGS(63) >= 0)
        REGS(n) = oThing(h)->isPlayer();
        return;
    case 106:
        VERIFY(h,T_THING,"isMonster")
        ASSERT(REGS(63) >= 0)
        REGS(n) = oThing(h)->isMonster();
        return;
    case 107:
        VERIFY(h,T_THING,"isWeapon")
        ASSERT(REGS(63) >= 0)
        REGS(n) = oThing(h)->isWeapon();
        return;
    case 108:
        VERIFY(h,T_THING,"isArmour")
        ASSERT(REGS(63) >= 0)
        REGS(n) = oThing(h)->isArmour();
        return;
    case 109:
        VERIFY(h,T_THING,"isFeature")
        ASSERT(REGS(63) >= 0)
        REGS(n) = oThing(h)->isFeature();
        return;
    case 110:
        VERIFY(h,T_THING,"isCharacter")
        ASSERT(REGS(63) >= 0)
        REGS(n) = oThing(h)->isCharacter();
        return;
    case 111:
        VERIFY(h,T_THING,"Material")
        ASSERT(REGS(63) >= 0)
        REGS(n) = oThing(h)->Material();
        return;
    case 112:
        VERIFY(h,T_THING,"isMetallic")
        ASSERT(REGS(63) >= 0)
        REGS(n) = oThing(h)->isMetallic();
        return;
    case 113:
        VERIFY(h,T_THING,"isWooden")
        ASSERT(REGS(63) >= 0)
        REGS(n) = oThing(h)->isWooden();
        return;
    case 114:
        VERIFY(h,T_THING,"isOrganic")
        ASSERT(REGS(63) >= 0)
        REGS(n) = oThing(h)->isOrganic();
        return;
    case 115:
        VERIFY(h,T_THING,"isCorporeal")
        ASSERT(REGS(63) >= 0)
        REGS(n) = oThing(h)->isCorporeal();
        return;
    case 116:
        VERIFY(h,T_THING,"Initialize")
        ASSERT(REGS(63) >= 1)
        oThing(h)->Initialize(STACK(1)!=0);
        return;
    case 117:
        VERIFY(h,T_THING,"SetImage")
        ASSERT(REGS(63) >= 0)
        oThing(h)->SetImage();
        return;
    case 118:
        VERIFY(h,T_THING,"IPrint")
        ASSERT(REGS(63) >= 1)
        oThing(h)->IPrint(GETSTR(STACK(1)),
                      VSTACK(2),VSTACK(3),VSTACK(4),VSTACK(5),VSTACK(6),VSTACK(7),VSTACK(8),VSTACK(9));
        return;
    case 119:
        VERIFY(h,T_THING,"IDPrint")
        ASSERT(REGS(63) >= 2)
        oThing(h)->IDPrint(GETSTR(STACK(1)), GETSTR(STACK(2)),
                      VSTACK(3),VSTACK(4),VSTACK(5),VSTACK(6),VSTACK(7),VSTACK(8),VSTACK(9),VSTACK(10));
        return;
    case 120:
        VERIFY(h,T_THING,"His")
        ASSERT(REGS(63) >= 0)
        GETSTR(-1) = oThing(h)->His();
        return;
    case 121:
        VERIFY(h,T_THING,"his")
        ASSERT(REGS(63) >= 0)
        GETSTR(-1) = oThing(h)->his();
        return;
    case 122:
        VERIFY(h,T_THING,"Him")
        ASSERT(REGS(63) >= 0)
        GETSTR(-1) = oThing(h)->Him();
        return;
    case 123:
        VERIFY(h,T_THING,"him")
        ASSERT(REGS(63) >= 0)
        GETSTR(-1) = oThing(h)->him();
        return;
    case 124:
        VERIFY(h,T_THING,"He")
        ASSERT(REGS(63) >= 0)
        GETSTR(-1) = oThing(h)->He();
        return;
    case 125:
        VERIFY(h,T_THING,"he")
        ASSERT(REGS(63) >= 0)
        GETSTR(-1) = oThing(h)->he();
        return;
    case 126:
        VERIFY(h,T_THING,"isPlural")
        ASSERT(REGS(63) >= 0)
        REGS(n) = oThing(h)->isPlural();
        return;
    case 127:
        VERIFY(h,T_THING,"isShadowShape")
        ASSERT(REGS(63) >= 0)
        REGS(n) = oThing(h)->isShadowShape();
        return;
    case 128:
        VERIFY(h,T_THING,"MoveDepth")
        ASSERT(REGS(63) >= 1)
        oThing(h)->MoveDepth((int16)STACK(1));
        return;
    case 129:
        VERIFY(h,T_THING,"PlaceNear")
        ASSERT(REGS(63) >= 2)
        oThing(h)->PlaceNear((int16)STACK(1), (int16)STACK(2));
        return;
    case 130:
        VERIFY(h,T_THING,"PlaceAt")
        ASSERT(REGS(63) >= 3)
        oThing(h)->PlaceAt(oMap(STACK(1)), (int16)STACK(2), (int16)STACK(3));
        return;
    case 131:
        VERIFY(h,T_THING,"PlaceOpen")
        ASSERT(REGS(63) >= 1)
        oThing(h)->PlaceOpen(oMap(STACK(1)));
        return;
    case 132:
        VERIFY(h,T_THING,"Remove")
        ASSERT(REGS(63) >= 1)
        oThing(h)->Remove(STACK(1)!=0);
        return;
    case 133:
        VERIFY(h,T_THING,"DirTo")
        ASSERT(REGS(63) >= 1)
        REGS(n) = oThing(h)->DirTo(oThing(STACK(1)));
        return;
    case 134:
        VERIFY(h,T_THING,"DirToXY")
        ASSERT(REGS(63) >= 2)
        REGS(n) = oThing(h)->DirToXY((int16)STACK(1), (int16)STACK(2));
        return;
    case 135:
        VERIFY(h,T_THING,"DistFrom")
        ASSERT(REGS(63) >= 1)
        REGS(n) = oThing(h)->DistFrom(oThing(STACK(1)));
        return;
    case 136:
        VERIFY(h,T_THING,"DistFromPlayer")
        ASSERT(REGS(63) >= 0)
        REGS(n) = oThing(h)->DistFromPlayer();
        return;
    case 137:
        VERIFY(h,T_THING,"isIllusion")
        ASSERT(REGS(63) >= 0)
        REGS(n) = oThing(h)->isIllusion();
        return;
    case 138:
        VERIFY(h,T_THING,"isRealTo")
        ASSERT(REGS(63) >= 1)
        REGS(n) = oThing(h)->isRealTo(oCreature(STACK(1)));
        return;
    case 139:
        VERIFY(h,T_THING,"onPlane")
        ASSERT(REGS(63) >= 0)
        REGS(n) = oThing(h)->onPlane();
        return;
    case 140:
        VERIFY(h,T_THING,"inField")
        ASSERT(REGS(63) >= 1)
        REGS(n) = oThing(h)->inField((int16)STACK(1));
        return;
    case 141:
        VERIFY(h,T_THING,"GainPermStati")
        ASSERT(REGS(63) >= 7)
        oThing(h)->GainPermStati((int16)STACK(1), oThing(STACK(2)), (int8)STACK(3), (int16)STACK(4), (int16)STACK(5), STACK(6), (int8)STACK(7));
        return;
    case 142:
        VERIFY(h,T_THING,"GainTempStati")
        ASSERT(REGS(63) >= 8)
        oThing(h)->GainTempStati((int16)STACK(1), oThing(STACK(2)), (int16)STACK(3), (int8)STACK(4), (int16)STACK(5), (int16)STACK(6), STACK(7), (int8)STACK(8));
        return;
    case 143:
        VERIFY(h,T_THING,"CopyStati")
        ASSERT(REGS(63) >= 2)
        oThing(h)->CopyStati(oThing(STACK(1)), (int16)STACK(2));
        return;
    case 144:
        VERIFY(h,T_THING,"RemoveStati")
        ASSERT(REGS(63) >= 5)
        oThing(h)->RemoveStati((int16)STACK(1), (int8)STACK(2), (int16)STACK(3), (int16)STACK(4), oThing(STACK(5)));
        return;
    case 145:
        VERIFY(h,T_THING,"RemoveEffStati")
        ASSERT(REGS(63) >= 1)
        oThing(h)->RemoveEffStati(STACK(1));
        return;
    case 146:
        VERIFY(h,T_THING,"RemoveStatiFrom")
        ASSERT(REGS(63) >= 1)
        oThing(h)->RemoveStatiFrom(oThing(STACK(1)));
        return;
    case 147:
        VERIFY(h,T_THING,"RemoveStatiSource")
        ASSERT(REGS(63) >= 1)
        oThing(h)->RemoveStatiSource((uint8)STACK(1));
        return;
    case 148:
        VERIFY(h,T_THING,"HighSourceCLev")
        ASSERT(REGS(63) >= 1)
        REGS(n) = oThing(h)->HighSourceCLev((uint8)STACK(1));
        return;
    case 149:
        VERIFY(h,T_THING,"HasStatiFromSource")
        ASSERT(REGS(63) >= 1)
        REGS(n) = oThing(h)->HasStatiFromSource((uint8)STACK(1));
        return;
    case 150:
        VERIFY(h,T_THING,"HasStati")
        ASSERT(REGS(63) >= 3)
        REGS(n) = oThing(h)->HasStati((int16)STACK(1), (int16)STACK(2), oThing(STACK(3)));
        return;
    case 151:
        VERIFY(h,T_THING,"HasEffStati")
        ASSERT(REGS(63) >= 4)
        REGS(n) = oThing(h)->HasEffStati((int16)STACK(1), STACK(2), (int16)STACK(3), oThing(STACK(4)));
        return;
    case 152:
        VERIFY(h,T_THING,"HasEffField")
        ASSERT(REGS(63) >= 1)
        REGS(n) = oThing(h)->HasEffField(STACK(1));
        return;
    case 153:
        VERIFY(h,T_THING,"GetStatiVal")
        ASSERT(REGS(63) >= 2)
        REGS(n) = oThing(h)->GetStatiVal((int16)STACK(1), oThing(STACK(2)));
        return;
    case 154:
        VERIFY(h,T_THING,"GetStatiMag")
        ASSERT(REGS(63) >= 3)
        REGS(n) = oThing(h)->GetStatiMag((int16)STACK(1), (int16)STACK(2), oThing(STACK(3)));
        return;
    case 155:
        VERIFY(h,T_THING,"GetStatiCause")
        ASSERT(REGS(63) >= 3)
        REGS(n) = oThing(h)->GetStatiCause((int16)STACK(1), (int16)STACK(2), oThing(STACK(3)));
        return;
    case 156:
        VERIFY(h,T_THING,"GetStatiObj")
        ASSERT(REGS(63) >= 3)
        t = oThing(h)->GetStatiObj((int16)STACK(1), (int16)STACK(2), oThing(STACK(3)));
        REGS(n) = t ? t->myHandle : 0;
        return;
    case 157:
        VERIFY(h,T_THING,"GetStatiDur")
        ASSERT(REGS(63) >= 3)
        REGS(n) = oThing(h)->GetStatiDur((int16)STACK(1), (int16)STACK(2), oThing(STACK(3)));
        return;
    case 158:
        VERIFY(h,T_THING,"GetStatiEID")
        ASSERT(REGS(63) >= 3)
        REGS(n) = oThing(h)->GetStatiEID((int16)STACK(1), (int16)STACK(2), oThing(STACK(3)));
        return;
    case 159:
        VERIFY(h,T_THING,"GetStatiCLev")
        ASSERT(REGS(63) >= 3)
        REGS(n) = oThing(h)->GetStatiCLev((int16)STACK(1), (int16)STACK(2), oThing(STACK(3)));
        return;
    case 160:
        VERIFY(h,T_THING,"SetStatiVal")
        ASSERT(REGS(63) >= 3)
        oThing(h)->SetStatiVal((int16)STACK(1), oThing(STACK(2)), (int16)STACK(3));
        return;
    case 161:
        VERIFY(h,T_THING,"SetStatiMag")
        ASSERT(REGS(63) >= 4)
        oThing(h)->SetStatiMag((int16)STACK(1), (int16)STACK(2), oThing(STACK(3)), (int16)STACK(4));
        return;
    case 162:
        VERIFY(h,T_THING,"SetStatiCause")
        ASSERT(REGS(63) >= 4)
        oThing(h)->SetStatiCause((int16)STACK(1), (int16)STACK(2), oThing(STACK(3)), (uint8)STACK(4));
        return;
    case 163:
        VERIFY(h,T_THING,"SetStatiObj")
        ASSERT(REGS(63) >= 3)
        oThing(h)->SetStatiObj((int16)STACK(1), (int16)STACK(2), oThing(STACK(3)));
        return;
    case 164:
        VERIFY(h,T_THING,"SetStatiDur")
        ASSERT(REGS(63) >= 4)
        oThing(h)->SetStatiDur((int16)STACK(1), (int16)STACK(2), oThing(STACK(3)), (int16)STACK(4));
        return;
    case 165:
        VERIFY(h,T_THING,"SetStatiEID")
        ASSERT(REGS(63) >= 4)
        oThing(h)->SetStatiEID((int16)STACK(1), (int16)STACK(2), oThing(STACK(3)), STACK(4));
        return;
    case 166:
        VERIFY(h,T_THING,"IncStatiMag")
        ASSERT(REGS(63) >= 5)
        oThing(h)->IncStatiMag((int16)STACK(1), (int8)STACK(2), (int16)STACK(3), oThing(STACK(4)), (int16)STACK(5));
        return;
    case 167:
        VERIFY(h,T_THING,"GetEffStatiVal")
        ASSERT(REGS(63) >= 4)
        REGS(n) = oThing(h)->GetEffStatiVal((int16)STACK(1), STACK(2), (int16)STACK(3), oThing(STACK(4)));
        return;
    case 168:
        VERIFY(h,T_THING,"GetEffStatiMag")
        ASSERT(REGS(63) >= 4)
        REGS(n) = oThing(h)->GetEffStatiMag((int16)STACK(1), STACK(2), (int16)STACK(3), oThing(STACK(4)));
        return;
    case 169:
        VERIFY(h,T_THING,"GetEffStatiCause")
        ASSERT(REGS(63) >= 4)
        REGS(n) = oThing(h)->GetEffStatiCause((int16)STACK(1), STACK(2), (int16)STACK(3), oThing(STACK(4)));
        return;
    case 170:
        VERIFY(h,T_THING,"GetEffStatiObj")
        ASSERT(REGS(63) >= 4)
        t = oThing(h)->GetEffStatiObj((int16)STACK(1), STACK(2), (int16)STACK(3), oThing(STACK(4)));
        REGS(n) = t ? t->myHandle : 0;
        return;
    case 171:
        VERIFY(h,T_THING,"GetEffStatiDur")
        ASSERT(REGS(63) >= 4)
        REGS(n) = oThing(h)->GetEffStatiDur((int16)STACK(1), STACK(2), (int16)STACK(3), oThing(STACK(4)));
        return;
    case 172:
        VERIFY(h,T_THING,"GetEffStatiCLev")
        ASSERT(REGS(63) >= 4)
        REGS(n) = oThing(h)->GetEffStatiCLev((int16)STACK(1), STACK(2), (int16)STACK(3), oThing(STACK(4)));
        return;
    case 173:
        VERIFY(h,T_THING,"SetEffStatiVal")
        ASSERT(REGS(63) >= 4)
        oThing(h)->SetEffStatiVal((int16)STACK(1), STACK(2), (int16)STACK(3), oThing(STACK(4)));
        return;
    case 174:
        VERIFY(h,T_THING,"SetEffStatiMag")
        ASSERT(REGS(63) >= 5)
        oThing(h)->SetEffStatiMag((int16)STACK(1), STACK(2), (int16)STACK(3), (int16)STACK(4), oThing(STACK(5)));
        return;
    case 175:
        VERIFY(h,T_THING,"SetEffStatiCause")
        ASSERT(REGS(63) >= 5)
        oThing(h)->SetEffStatiCause((int16)STACK(1), STACK(2), (uint8)STACK(3), (int16)STACK(4), oThing(STACK(5)));
        return;
    case 176:
        VERIFY(h,T_THING,"SetEffStatiObj")
        ASSERT(REGS(63) >= 4)
        oThing(h)->SetEffStatiObj((int16)STACK(1), STACK(2), oThing(STACK(3)), (int16)STACK(4));
        return;
    case 177:
        VERIFY(h,T_THING,"SetEffStatiDur")
        ASSERT(REGS(63) >= 5)
        oThing(h)->SetEffStatiDur((int16)STACK(1), STACK(2), (int16)STACK(3), (int16)STACK(4), oThing(STACK(5)));
        return;
    case 178:
        VERIFY(h,T_THING,"IncEffStatiMag")
        ASSERT(REGS(63) >= 6)
        oThing(h)->IncEffStatiMag((int16)STACK(1), STACK(2), (int8)STACK(3), oThing(STACK(4)), (int16)STACK(5), (int16)STACK(6));
        return;
    case 179:
        VERIFY(h,T_THING,"SumStatiMag")
        ASSERT(REGS(63) >= 3)
        REGS(n) = oThing(h)->SumStatiMag((int16)STACK(1), (int16)STACK(2), oThing(STACK(3)));
        return;
    case 180:
        VERIFY(h,T_THING,"HighStatiMag")
        ASSERT(REGS(63) >= 3)
        REGS(n) = oThing(h)->HighStatiMag((int16)STACK(1), (int16)STACK(2), oThing(STACK(3)));
        return;
    case 181:
        VERIFY(h,T_THING,"SumStatiVal")
        ASSERT(REGS(63) >= 2)
        REGS(n) = oThing(h)->SumStatiVal((int16)STACK(1), oThing(STACK(2)));
        return;
    case 182:
        VERIFY(h,T_THING,"XORStatiVal")
        ASSERT(REGS(63) >= 2)
        REGS(n) = oThing(h)->XORStatiVal((int16)STACK(1), oThing(STACK(2)));
        return;
    case 183:
        VERIFY(h,T_THING,"CountStati")
        ASSERT(REGS(63) >= 3)
        REGS(n) = oThing(h)->CountStati((int16)STACK(1), (int16)STACK(2), oThing(STACK(3)));
        return;
    case 184:
        VERIFY(h,T_THING,"CountEffStati")
        ASSERT(REGS(63) >= 3)
        REGS(n) = oThing(h)->CountEffStati((int16)STACK(1), STACK(2), (int16)STACK(3));
        return;
    case 185:
        VERIFY(h,T_CREATURE,"cMana")
        ASSERT(REGS(63) >= 0)
        REGS(n) = oCreature(h)->cMana();
        return;
    case 186:
        VERIFY(h,T_CREATURE,"tMana")
        ASSERT(REGS(63) >= 0)
        REGS(n) = oCreature(h)->tMana();
        return;
    case 187:
        VERIFY(h,T_CREATURE,"nhMana")
        ASSERT(REGS(63) >= 0)
        REGS(n) = oCreature(h)->nhMana();
        return;
    case 188:
        VERIFY(h,T_CREATURE,"LoseMana")
        ASSERT(REGS(63) >= 2)
        oCreature(h)->LoseMana(STACK(1), STACK(2)!=0);
        return;
    case 189:
        VERIFY(h,T_CREATURE,"GainMana")
        ASSERT(REGS(63) >= 1)
        oCreature(h)->GainMana(STACK(1));
        return;
    case 190:
        VERIFY(h,T_CREATURE,"AttackMode")
        ASSERT(REGS(63) >= 0)
        REGS(n) = oCreature(h)->AttackMode();
        return;
    case 191:
        VERIFY(h,T_CREATURE,"GetAttr")
        ASSERT(REGS(63) >= 1)
        REGS(n) = oCreature(h)->GetAttr((int8)STACK(1));
        return;
    case 192:
        VERIFY(h,T_CREATURE,"KnownAttr")
        ASSERT(REGS(63) >= 1)
        REGS(n) = oCreature(h)->KnownAttr((int8)STACK(1));
        return;
    case 193:
        VERIFY(h,T_CREATURE,"Exercise")
        ASSERT(REGS(63) >= 4)
        oCreature(h)->Exercise((int16)STACK(1), (int16)STACK(2), (int16)STACK(3), (int16)STACK(4));
        return;
    case 194:
        VERIFY(h,T_CREATURE,"Abuse")
        ASSERT(REGS(63) >= 2)
        oCreature(h)->Abuse((int16)STACK(1), (int16)STACK(2));
        return;
    case 195:
        VERIFY(h,T_CREATURE,"isBlind")
        ASSERT(REGS(63) >= 0)
        REGS(n) = oCreature(h)->isBlind();
        return;
    case 196:
        VERIFY(h,T_CREATURE,"ChooseAction")
        ASSERT(REGS(63) >= 0)
        oCreature(h)->ChooseAction();
        return;
    case 197:
        VERIFY(h,T_CREATURE,"ExtendedAction")
        ASSERT(REGS(63) >= 0)
        oCreature(h)->ExtendedAction();
        return;
    case 198:
        VERIFY(h,T_CREATURE,"ChallengeRating")
        ASSERT(REGS(63) >= 1)
        REGS(n) = oCreature(h)->ChallengeRating(STACK(1)!=0);
        return;
    case 199:
        VERIFY(h,T_CREATURE,"GainXP")
        ASSERT(REGS(63) >= 1)
        oCreature(h)->GainXP(STACK(1));
        return;
    case 200:
        VERIFY(h,T_CREATURE,"KillXP")
        ASSERT(REGS(63) >= 1)
        oCreature(h)->KillXP(oCreature(STACK(1)));
        return;
    case 201:
        VERIFY(h,T_CREATURE,"XPDrained")
        ASSERT(REGS(63) >= 0)
        REGS(n) = oCreature(h)->XPDrained();
        return;
    case 202:
        VERIFY(h,T_CREATURE,"RestoreXP")
        ASSERT(REGS(63) >= 1)
        oCreature(h)->RestoreXP(STACK(1));
        return;
    case 203:
        VERIFY(h,T_CREATURE,"DevourMonster")
        ASSERT(REGS(63) >= 1)
        oCreature(h)->DevourMonster(oMonster(STACK(1)));
        return;
    case 204:
        VERIFY(h,T_CREATURE,"Perceives")
        ASSERT(REGS(63) >= 1)
        REGS(n) = oCreature(h)->Perceives(oThing(STACK(1)));
        return;
    case 205:
        VERIFY(h,T_CREATURE,"isBeside")
        ASSERT(REGS(63) >= 1)
        REGS(n) = oCreature(h)->isBeside(oThing(STACK(1)));
        return;
    case 206:
        VERIFY(h,T_CREATURE,"isSmallRace")
        ASSERT(REGS(63) >= 0)
        REGS(n) = oCreature(h)->isSmallRace();
        return;
    case 207:
        VERIFY(h,T_CREATURE,"ItemPrereq")
        ASSERT(REGS(63) >= 3)
        REGS(n) = oCreature(h)->ItemPrereq(STACK(1), (int16)STACK(2), (int16)STACK(3));
        return;
    case 208:
        VERIFY(h,T_CREATURE,"yn")
        ASSERT(REGS(63) >= 2)
        REGS(n) = oCreature(h)->yn(GETSTR(STACK(1)), STACK(2)!=0);
        return;
    case 209:
        VERIFY(h,T_CREATURE,"canTalk")
        ASSERT(REGS(63) >= 0)
        REGS(n) = oCreature(h)->canTalk();
        return;
    case 210:
        VERIFY(h,T_CREATURE,"ArmourType")
        ASSERT(REGS(63) >= 0)
        REGS(n) = oCreature(h)->ArmourType();
        return;
    case 211:
        VERIFY(h,T_CREATURE,"Encumbrance")
        ASSERT(REGS(63) >= 0)
        REGS(n) = oCreature(h)->Encumbrance();
        return;
    case 212:
        VERIFY(h,T_CREATURE,"HasAttk")
        ASSERT(REGS(63) >= 1)
        REGS(n) = oCreature(h)->HasAttk((int8)STACK(1));
        return;
    case 213:
        VERIFY(h,T_CREATURE,"HasMFlag")
        ASSERT(REGS(63) >= 1)
        REGS(n) = oCreature(h)->HasMFlag((int16)STACK(1));
        return;
    case 214:
        VERIFY(h,T_CREATURE,"HasFeat")
        ASSERT(REGS(63) >= 1)
        REGS(n) = oCreature(h)->HasFeat((int16)STACK(1));
        return;
    case 215:
        VERIFY(h,T_CREATURE,"HasAbility")
        ASSERT(REGS(63) >= 1)
        REGS(n) = oCreature(h)->HasAbility((int16)STACK(1));
        return;
    case 216:
        VERIFY(h,T_CREATURE,"IHasFeat")
        ASSERT(REGS(63) >= 1)
        REGS(n) = oCreature(h)->IHasFeat((int16)STACK(1));
        return;
    case 217:
        VERIFY(h,T_CREATURE,"IHasAbility")
        ASSERT(REGS(63) >= 1)
        REGS(n) = oCreature(h)->IHasAbility((int16)STACK(1));
        return;
    case 218:
        VERIFY(h,T_CREATURE,"AbilityLevel")
        ASSERT(REGS(63) >= 1)
        REGS(n) = oCreature(h)->AbilityLevel((int16)STACK(1));
        return;
    case 219:
        VERIFY(h,T_CREATURE,"SkillLevel")
        ASSERT(REGS(63) >= 1)
        REGS(n) = oCreature(h)->SkillLevel((int16)STACK(1));
        return;
    case 220:
        VERIFY(h,T_CREATURE,"ISkillLevel")
        ASSERT(REGS(63) >= 1)
        REGS(n) = oCreature(h)->ISkillLevel((int16)STACK(1));
        return;
    case 221:
        VERIFY(h,T_CREATURE,"SkillCheck")
        ASSERT(REGS(63) >= 4)
        REGS(n) = oCreature(h)->SkillCheck((int16)STACK(1), (int16)STACK(2), STACK(3)!=0, (int16)STACK(4));
        return;
    case 222:
        VERIFY(h,T_CREATURE,"WepSkill")
        ASSERT(REGS(63) >= 1)
        REGS(n) = oCreature(h)->WepSkill(STACK(1));
        return;
    case 223:
        VERIFY(h,T_CREATURE,"CalcValues")
        ASSERT(REGS(63) >= 0)
        oCreature(h)->CalcValues();
        return;
    case 224:
        VERIFY(h,T_CREATURE,"CalcHP")
        ASSERT(REGS(63) >= 0)
        oCreature(h)->CalcHP();
        return;
    case 225:
        VERIFY(h,T_CREATURE,"Mod")
        ASSERT(REGS(63) >= 1)
        REGS(n) = oCreature(h)->Mod((int8)STACK(1));
        return;
    case 226:
        VERIFY(h,T_CREATURE,"Mod2")
        ASSERT(REGS(63) >= 1)
        REGS(n) = oCreature(h)->Mod2((int8)STACK(1));
        return;
    case 227:
        VERIFY(h,T_CREATURE,"KMod")
        ASSERT(REGS(63) >= 1)
        REGS(n) = oCreature(h)->KMod((int8)STACK(1));
        return;
    case 228:
        VERIFY(h,T_CREATURE,"KMod2")
        ASSERT(REGS(63) >= 1)
        REGS(n) = oCreature(h)->KMod2((int8)STACK(1));
        return;
    case 229:
        VERIFY(h,T_CREATURE,"SkillAttr")
        ASSERT(REGS(63) >= 1)
        REGS(n) = oCreature(h)->SkillAttr((int16)STACK(1));
        return;
    case 230:
        VERIFY(h,T_CREATURE,"SavingThrow")
        ASSERT(REGS(63) >= 3)
        REGS(n) = oCreature(h)->SavingThrow((int16)STACK(1), (int16)STACK(2), STACK(3));
        return;
    case 231:
        VERIFY(h,T_CREATURE,"TrainAs")
        ASSERT(REGS(63) >= 1)
        oCreature(h)->TrainAs(STACK(1));
        return;
    case 232:
        VERIFY(h,T_CREATURE,"HungerState")
        ASSERT(REGS(63) >= 0)
        REGS(n) = oCreature(h)->HungerState();
        return;
    case 233:
        VERIFY(h,T_CREATURE,"ConsumeRope")
        ASSERT(REGS(63) >= 1)
        t = oCreature(h)->ConsumeRope(STACK(1));
        REGS(n) = t ? t->myHandle : 0;
        return;
    case 234:
        VERIFY(h,T_CREATURE,"LoseFatigue")
        ASSERT(REGS(63) >= 2)
        REGS(n) = oCreature(h)->LoseFatigue((int16)STACK(1), STACK(2)!=0);
        return;
    case 235:
        VERIFY(h,T_CREATURE,"Shapeshift")
        ASSERT(REGS(63) >= 3)
        oCreature(h)->Shapeshift(STACK(1), STACK(2)!=0, oItem(STACK(3)));
        return;
    case 236:
        VERIFY(h,T_CREATURE,"ResistLevel")
        ASSERT(REGS(63) >= 1)
        REGS(n) = oCreature(h)->ResistLevel((int16)STACK(1));
        return;
    case 237:
        VERIFY(h,T_CREATURE,"SpellRating")
        ASSERT(REGS(63) >= 3)
        REGS(n) = oCreature(h)->SpellRating(STACK(1), STACK(2), STACK(3)!=0);
        return;
    case 238:
        VERIFY(h,T_CREATURE,"CasterLev")
        ASSERT(REGS(63) >= 0)
        REGS(n) = oCreature(h)->CasterLev();
        return;
    case 239:
        VERIFY(h,T_CREATURE,"getGod")
        ASSERT(REGS(63) >= 0)
        REGS(n) = oCreature(h)->getGod();
        return;
    case 240:
        VERIFY(h,T_CREATURE,"GetAgeCatagory")
        ASSERT(REGS(63) >= 0)
        REGS(n) = oCreature(h)->GetAgeCatagory();
        return;
    case 241:
        VERIFY(h,T_CREATURE,"DropAll")
        ASSERT(REGS(63) >= 0)
        oCreature(h)->DropAll();
        return;
    case 242:
        VERIFY(h,T_CREATURE,"InSlot")
        ASSERT(REGS(63) >= 1)
        t = oCreature(h)->InSlot((int8)STACK(1));
        REGS(n) = t ? t->myHandle : 0;
        return;
    case 243:
        VERIFY(h,T_CREATURE,"FirstInv")
        ASSERT(REGS(63) >= 0)
        t = oCreature(h)->FirstInv();
        REGS(n) = t ? t->myHandle : 0;
        return;
    case 244:
        VERIFY(h,T_CREATURE,"NextInv")
        ASSERT(REGS(63) >= 0)
        t = oCreature(h)->NextInv();
        REGS(n) = t ? t->myHandle : 0;
        return;
    case 245:
        VERIFY(h,T_CREATURE,"HasSkill")
        ASSERT(REGS(63) >= 1)
        REGS(n) = oCreature(h)->HasSkill((int16)STACK(1));
        return;
    case 246:
        VERIFY(h,T_CREATURE,"HasInnateSpell")
        ASSERT(REGS(63) >= 1)
        REGS(n) = oCreature(h)->HasInnateSpell(STACK(1));
        return;
    case 247:
        VERIFY(h,T_CREATURE,"GetBAB")
        ASSERT(REGS(63) >= 1)
        REGS(n) = oCreature(h)->GetBAB((int16)STACK(1));
        return;
    case 248:
        VERIFY(h,T_CREATURE,"FindBestItemOrCreate")
        ASSERT(REGS(63) >= 1)
        t = oCreature(h)->FindBestItemOrCreate(STACK(1));
        REGS(n) = t ? t->myHandle : 0;
        return;
    case 249:
        VERIFY(h,T_CREATURE,"GainItem")
        ASSERT(REGS(63) >= 2)
        oCreature(h)->GainItem(oItem(STACK(1)), STACK(2)!=0);
        return;
    case 250:
        VERIFY(h,T_CREATURE,"IdentByTrial")
        ASSERT(REGS(63) >= 1)
        oCreature(h)->IdentByTrial(oItem(STACK(1)));
        return;
    case 251:
        VERIFY(h,T_CREATURE,"GainInherentBonus")
        ASSERT(REGS(63) >= 3)
        oCreature(h)->GainInherentBonus((int16)STACK(1), (int16)STACK(2), STACK(3)!=0);
        return;
    case 252:
        VERIFY(h,T_CREATURE,"Reveal")
        ASSERT(REGS(63) >= 1)
        oCreature(h)->Reveal(STACK(1)!=0);
        return;
    case 253:
        VERIFY(h,T_CREATURE,"ProvokeAoO")
        ASSERT(REGS(63) >= 0)
        oCreature(h)->ProvokeAoO();
        return;
    case 254:
        VERIFY(h,T_CREATURE,"ManeuverCheck")
        ASSERT(REGS(63) >= 1)
        oCreature(h)->ManeuverCheck(*pe);
        return;
    case 255:
        VERIFY(h,T_CREATURE,"isHostileTo")
        ASSERT(REGS(63) >= 1)
        REGS(n) = oCreature(h)->isHostileTo(oCreature(STACK(1)));
        return;
    case 256:
        VERIFY(h,T_CREATURE,"isHostileToPartyOf")
        ASSERT(REGS(63) >= 1)
        REGS(n) = oCreature(h)->isHostileToPartyOf(oCreature(STACK(1)));
        return;
    case 257:
        VERIFY(h,T_CREATURE,"isFriendlyTo")
        ASSERT(REGS(63) >= 1)
        REGS(n) = oCreature(h)->isFriendlyTo(oCreature(STACK(1)));
        return;
    case 258:
        VERIFY(h,T_CREATURE,"isThreatened")
        ASSERT(REGS(63) >= 0)
        REGS(n) = oCreature(h)->isThreatened();
        return;
    case 259:
        VERIFY(h,T_CREATURE,"getLeader")
        ASSERT(REGS(63) >= 0)
        t = oCreature(h)->getLeader();
        REGS(n) = t ? t->myHandle : 0;
        return;
    case 260:
        VERIFY(h,T_CREATURE,"getLeaderOrFirst")
        ASSERT(REGS(63) >= 0)
        t = oCreature(h)->getLeaderOrFirst();
        REGS(n) = t ? t->myHandle : 0;
        return;
    case 261:
        VERIFY(h,T_CREATURE,"isLedBy")
        ASSERT(REGS(63) >= 1)
        REGS(n) = oCreature(h)->isLedBy(oCreature(STACK(1)));
        return;
    case 262:
        VERIFY(h,T_CREATURE,"worstTrouble")
        ASSERT(REGS(63) >= 0)
        REGS(n) = oCreature(h)->worstTrouble();
        return;
    case 263:
        VERIFY(h,T_CREATURE,"Transgress")
        ASSERT(REGS(63) >= 4)
        oCreature(h)->Transgress(STACK(1), (int16)STACK(2), STACK(3)!=0, GETSTR(STACK(4)));
        return;
    case 264:
        VERIFY(h,T_CREATURE,"IdentifyMon")
        ASSERT(REGS(63) >= 0)
        oCreature(h)->IdentifyMon();
        return;
    case 265:
        VERIFY(h,T_CREATURE,"IdentifyTemp")
        ASSERT(REGS(63) >= 1)
        oCreature(h)->IdentifyTemp(STACK(1));
        return;
    case 266:
        VERIFY(h,T_CREATURE,"isMType")
        ASSERT(REGS(63) >= 1)
        REGS(n) = oCreature(h)->isMType(STACK(1));
        return;
    case 267:
        VERIFY(h,T_CREATURE,"isAerial")
        ASSERT(REGS(63) >= 0)
        REGS(n) = oCreature(h)->isAerial();
        return;
    case 268:
        VERIFY(h,T_CREATURE,"isFlatFooted")
        ASSERT(REGS(63) >= 0)
        REGS(n) = oCreature(h)->isFlatFooted();
        return;
    case 269:
        VERIFY(h,T_CREATURE,"ChoicePrompt")
        ASSERT(REGS(63) >= 5)
        REGS(n) = oCreature(h)->ChoicePrompt(GETSTR(STACK(1)), GETSTR(STACK(2)), (int8)STACK(3), (int8)STACK(4), (int8)STACK(5));
        return;
    case 270:
        VERIFY(h,T_CREATURE,"AddTemplate")
        ASSERT(REGS(63) >= 1)
        oCreature(h)->AddTemplate(STACK(1));
        return;
    case 271:
        VERIFY(h,T_CREATURE,"CanAddTemplate")
        ASSERT(REGS(63) >= 1)
        REGS(n) = oCreature(h)->CanAddTemplate(STACK(1));
        return;
    case 272:
        VERIFY(h,T_CREATURE,"Awaken")
        ASSERT(REGS(63) >= 0)
        oCreature(h)->Awaken();
        return;
    case 273:
        VERIFY(h,T_CREATURE,"getSocialMod")
        ASSERT(REGS(63) >= 2)
        REGS(n) = oCreature(h)->getSocialMod(oCreature(STACK(1)), STACK(2)!=0);
        return;
    case 274:
        VERIFY(h,T_CREATURE,"MakeNoise")
        ASSERT(REGS(63) >= 1)
        oCreature(h)->MakeNoise((int16)STACK(1));
        return;
    case 275:
        VERIFY(h,T_CREATURE,"Multiply")
        ASSERT(REGS(63) >= 3)
        oCreature(h)->Multiply((int16)STACK(1), STACK(2)!=0, STACK(3)!=0);
        return;
    case 276:
        VERIFY(h,T_CREATURE,"StatiMessage")
        ASSERT(REGS(63) >= 3)
        oCreature(h)->StatiMessage((int16)STACK(1), (int16)STACK(2), STACK(3)!=0);
        return;
    case 277:
        VERIFY(h,T_CREATURE,"RandInv")
        ASSERT(REGS(63) >= 0)
        t = oCreature(h)->RandInv();
        REGS(n) = t ? t->myHandle : 0;
        return;
    case 278:
        VERIFY(h,T_CREATURE,"RandGoodInv")
        ASSERT(REGS(63) >= 1)
        t = oCreature(h)->RandGoodInv(STACK(1));
        REGS(n) = t ? t->myHandle : 0;
        return;
    case 279:
        VERIFY(h,T_CREATURE,"rateMeleeWeapon")
        ASSERT(REGS(63) >= 0)
        REGS(n) = oCreature(h)->rateMeleeWeapon();
        return;
    case 280:
        VERIFY(h,T_CREATURE,"rateRangedWeapon")
        ASSERT(REGS(63) >= 0)
        REGS(n) = oCreature(h)->rateRangedWeapon();
        return;
    case 281:
        VERIFY(h,T_CREATURE,"getPrimaryMelee")
        ASSERT(REGS(63) >= 0)
        t = oCreature(h)->getPrimaryMelee();
        REGS(n) = t ? t->myHandle : 0;
        return;
    case 282:
        VERIFY(h,T_CREATURE,"getPrimaryRanged")
        ASSERT(REGS(63) >= 0)
        t = oCreature(h)->getPrimaryRanged();
        REGS(n) = t ? t->myHandle : 0;
        return;
    case 283:
        VERIFY(h,T_CREATURE,"HaltAction")
        ASSERT(REGS(63) >= 2)
        oCreature(h)->HaltAction(GETSTR(STACK(1)), STACK(2)!=0);
        return;
    case 284:
        VERIFY(h,T_CHARACTER,"kcMana")
        ASSERT(REGS(63) >= 0)
        REGS(n) = oCharacter(h)->kcMana();
        return;
    case 285:
        VERIFY(h,T_CHARACTER,"ktMana")
        ASSERT(REGS(63) >= 0)
        REGS(n) = oCharacter(h)->ktMana();
        return;
    case 286:
        VERIFY(h,T_CHARACTER,"Swap")
        ASSERT(REGS(63) >= 1)
        REGS(n) = oCharacter(h)->Swap((int8)STACK(1));
        return;
    case 287:
        VERIFY(h,T_CHARACTER,"AddAbilities")
        ASSERT(REGS(63) >= 2)
        oCharacter(h)->AddAbilities(STACK(1), (int16)STACK(2));
        return;
    case 288:
        VERIFY(h,T_CHARACTER,"GainFeat")
        ASSERT(REGS(63) >= 1)
        oCharacter(h)->GainFeat((int16)STACK(1));
        return;
    case 289:
        VERIFY(h,T_CHARACTER,"GainAbility")
        ASSERT(REGS(63) >= 4)
        oCharacter(h)->GainAbility((int16)STACK(1), STACK(2), STACK(3), (int16)STACK(4));
        return;
    case 290:
        VERIFY(h,T_CHARACTER,"GainBonusSkills")
        ASSERT(REGS(63) >= 2)
        oCharacter(h)->GainBonusSkills(STACK(1), (int16)STACK(2));
        return;
    case 291:
        VERIFY(h,T_CHARACTER,"FeatPrereq")
        ASSERT(REGS(63) >= 1)
        oCharacter(h)->FeatPrereq((int16)STACK(1));
        return;
    case 292:
        VERIFY(h,T_CHARACTER,"NextLevXP")
        ASSERT(REGS(63) >= 0)
        REGS(n) = oCharacter(h)->NextLevXP();
        return;
    case 293:
        VERIFY(h,T_CHARACTER,"XPPenalty")
        ASSERT(REGS(63) >= 0)
        REGS(n) = oCharacter(h)->XPPenalty();
        return;
    case 294:
        VERIFY(h,T_CHARACTER,"LoseXP")
        ASSERT(REGS(63) >= 1)
        oCharacter(h)->LoseXP(STACK(1));
        return;
    case 295:
        VERIFY(h,T_CHARACTER,"TotalXP")
        ASSERT(REGS(63) >= 0)
        REGS(n) = oCharacter(h)->TotalXP();
        return;
    case 296:
        VERIFY(h,T_CHARACTER,"IAttr")
        ASSERT(REGS(63) >= 1)
        REGS(n) = oCharacter(h)->IAttr((int8)STACK(1));
        return;
    case 297:
        VERIFY(h,T_CHARACTER,"LevelAs")
        ASSERT(REGS(63) >= 1)
        REGS(n) = oCharacter(h)->LevelAs(STACK(1));
        return;
    case 298:
        VERIFY(h,T_CHARACTER,"TotalLevel")
        ASSERT(REGS(63) >= 0)
        REGS(n) = oCharacter(h)->TotalLevel();
        return;
    case 299:
        VERIFY(h,T_CHARACTER,"SpellKnown")
        ASSERT(REGS(63) >= 1)
        REGS(n) = oCharacter(h)->SpellKnown((int16)STACK(1));
        return;
    case 300:
        VERIFY(h,T_CHARACTER,"getSpellFlags")
        ASSERT(REGS(63) >= 1)
        REGS(n) = oCharacter(h)->getSpellFlags(STACK(1));
        return;
    case 301:
        VERIFY(h,T_CHARACTER,"setSpellFlags")
        ASSERT(REGS(63) >= 2)
        oCharacter(h)->setSpellFlags(STACK(1), (uint16)STACK(2));
        return;
    case 302:
        VERIFY(h,T_CHARACTER,"GetSkillRanks")
        ASSERT(REGS(63) >= 1)
        REGS(n) = oCharacter(h)->GetSkillRanks((int16)STACK(1));
        return;
    case 303:
        VERIFY(h,T_CHARACTER,"SetInvSlot")
        ASSERT(REGS(63) >= 2)
        oCharacter(h)->SetInvSlot((int16)STACK(1), oItem(STACK(2)));
        return;
    case 304:
        VERIFY(h,T_CHARACTER,"UseFeat")
        ASSERT(REGS(63) >= 1)
        oCharacter(h)->UseFeat((int16)STACK(1));
        return;
    case 305:
        VERIFY(h,T_CHARACTER,"UseSkill")
        ASSERT(REGS(63) >= 1)
        oCharacter(h)->UseSkill((uint8)STACK(1));
        return;
    case 306:
        VERIFY(h,T_CHARACTER,"UseAbility")
        ASSERT(REGS(63) >= 2)
        oCharacter(h)->UseAbility((uint8)STACK(1), (int16)STACK(2));
        return;
    case 307:
        VERIFY(h,T_CHARACTER,"GodMessage")
        ASSERT(REGS(63) >= 2)
        oCharacter(h)->GodMessage(STACK(1), (int16)STACK(2),
                      VSTACK(3),VSTACK(4),VSTACK(5),VSTACK(6),VSTACK(7),VSTACK(8),VSTACK(9),VSTACK(10));
        return;
    case 308:
        VERIFY(h,T_CHARACTER,"calcFavour")
        ASSERT(REGS(63) >= 1)
        REGS(n) = oCharacter(h)->calcFavour(STACK(1));
        return;
    case 309:
        VERIFY(h,T_CHARACTER,"gainFavour")
        ASSERT(REGS(63) >= 4)
        oCharacter(h)->gainFavour(STACK(1), STACK(2), STACK(3)!=0, STACK(4)!=0);
        return;
    case 310:
        VERIFY(h,T_CHARACTER,"lowerAnger")
        ASSERT(REGS(63) >= 2)
        oCharacter(h)->lowerAnger(STACK(1), (int16)STACK(2));
        return;
    case 311:
        VERIFY(h,T_CHARACTER,"AlignedAct")
        ASSERT(REGS(63) >= 3)
        oCharacter(h)->AlignedAct((uint16)STACK(1), (int16)STACK(2), GETSTR(STACK(3)));
        return;
    case 312:
        VERIFY(h,T_CHARACTER,"getGodFlags")
        ASSERT(REGS(63) >= 1)
        REGS(n) = oCharacter(h)->getGodFlags(STACK(1));
        return;
    case 313:
        VERIFY(h,T_CHARACTER,"getGodLevel")
        ASSERT(REGS(63) >= 1)
        REGS(n) = oCharacter(h)->getGodLevel(STACK(1));
        return;
    case 314:
        VERIFY(h,T_CHARACTER,"getGodAnger")
        ASSERT(REGS(63) >= 1)
        REGS(n) = oCharacter(h)->getGodAnger(STACK(1));
        return;
    case 315:
        VERIFY(h,T_CHARACTER,"setGodFlags")
        ASSERT(REGS(63) >= 2)
        oCharacter(h)->setGodFlags(STACK(1), (uint16)STACK(2));
        return;
    case 316:
        VERIFY(h,T_CHARACTER,"resetGodFlags")
        ASSERT(REGS(63) >= 2)
        oCharacter(h)->resetGodFlags(STACK(1), (uint16)STACK(2));
        return;
    case 317:
        VERIFY(h,T_CHARACTER,"Forsake")
        ASSERT(REGS(63) >= 0)
        oCharacter(h)->Forsake();
        return;
    case 318:
        VERIFY(h,T_CHARACTER,"isWorthyOf")
        ASSERT(REGS(63) >= 2)
        REGS(n) = oCharacter(h)->isWorthyOf(STACK(1), STACK(2)!=0);
        return;
    case 319:
        VERIFY(h,T_CHARACTER,"getAnger")
        ASSERT(REGS(63) >= 1)
        REGS(n) = oCharacter(h)->getAnger(STACK(1));
        return;
    case 320:
        VERIFY(h,T_CHARACTER,"SwapAttributes")
        ASSERT(REGS(63) >= 1)
        oCharacter(h)->SwapAttributes((int16)STACK(1));
        return;
    case 321:
        VERIFY(h,T_CHARACTER,"TotalExploreFavour")
        ASSERT(REGS(63) >= 0)
        REGS(n) = oCharacter(h)->TotalExploreFavour();
        return;
    case 322:
        VERIFY(h,T_MONSTER,"MakeCompanion")
        ASSERT(REGS(63) >= 2)
        REGS(n) = oMonster(h)->MakeCompanion(oPlayer(STACK(1)), (int16)STACK(2));
        return;
    case 323:
        VERIFY(h,T_MONSTER,"Pacify")
        ASSERT(REGS(63) >= 1)
        oMonster(h)->Pacify(oCreature(STACK(1)));
        return;
    case 324:
        VERIFY(h,T_MONSTER,"TurnHostileTo")
        ASSERT(REGS(63) >= 1)
        oMonster(h)->TurnHostileTo(oCreature(STACK(1)));
        return;
    case 325:
        VERIFY(h,T_MONSTER,"TurnNeutralTo")
        ASSERT(REGS(63) >= 1)
        oMonster(h)->TurnNeutralTo(oCreature(STACK(1)));
        return;
    case 326:
        VERIFY(h,T_PLAYER,"GainSpell")
        ASSERT(REGS(63) >= 2)
        oPlayer(h)->GainSpell(STACK(1), (int16)STACK(2));
        return;
    case 327:
        VERIFY(h,T_PLAYER,"FirstAutoBuff")
        ASSERT(REGS(63) >= 0)
        REGS(n) = oPlayer(h)->FirstAutoBuff();
        return;
    case 328:
        VERIFY(h,T_PLAYER,"NextAutoBuff")
        ASSERT(REGS(63) >= 0)
        REGS(n) = oPlayer(h)->NextAutoBuff();
        return;
    case 329:
        VERIFY(h,T_PLAYER,"SpendHours")
        ASSERT(REGS(63) >= 2)
        REGS(n) = oPlayer(h)->SpendHours((int16)STACK(1), (int16)STACK(2));
        return;
    case 330:
        VERIFY(h,T_PLAYER,"FixSummonCR")
        ASSERT(REGS(63) >= 2)
        REGS(n) = oPlayer(h)->FixSummonCR((int16)STACK(1), (int16)STACK(2));
        return;
    case 331:
        VERIFY(h,T_PLAYER,"getMaxDepth")
        ASSERT(REGS(63) >= 1)
        REGS(n) = oPlayer(h)->getMaxDepth(STACK(1));
        return;
    case 332:
        VERIFY(h,T_PLAYER,"BonusBreakdown")
        ASSERT(REGS(63) >= 2)
        GETSTR(-1) = oPlayer(h)->BonusBreakdown((int8)STACK(1), (int16)STACK(2));
        return;
    case 333:
        VERIFY(h,T_PLAYER,"Seen")
        ASSERT(REGS(63) >= 2)
        REGS(n) = oPlayer(h)->Seen((int16)STACK(1), (int16)STACK(2));
        return;
    case 334:
        VERIFY(h,T_PLAYER,"Opt")
        ASSERT(REGS(63) >= 1)
        REGS(n) = oPlayer(h)->Opt((int16)STACK(1));
        return;
    case 335:
        VERIFY(h,T_MONSTER,"AddAct")
        ASSERT(REGS(63) >= 4)
        oMonster(h)->AddAct((int8)STACK(1), (int8)STACK(2), oThing(STACK(3)), (int16)STACK(4));
        return;
    case 336:
        VERIFY(h,T_ITEM,"Owner")
        ASSERT(REGS(63) >= 0)
        t = oItem(h)->Owner();
        REGS(n) = t ? t->myHandle : 0;
        return;
    case 337:
        VERIFY(h,T_ITEM,"Size")
        ASSERT(REGS(63) >= 1)
        REGS(n) = oItem(h)->Size(oCreature(STACK(1)));
        return;
    case 338:
        VERIFY(h,T_ITEM,"GetParent")
        ASSERT(REGS(63) >= 0)
        t = oItem(h)->GetParent();
        REGS(n) = t ? t->myHandle : 0;
        return;
    case 339:
        VERIFY(h,T_ITEM,"isActivatable")
        ASSERT(REGS(63) >= 0)
        REGS(n) = oItem(h)->isActivatable();
        return;
    case 340:
        VERIFY(h,T_ITEM,"ChangeIID")
        ASSERT(REGS(63) >= 1)
        oItem(h)->ChangeIID(STACK(1));
        return;
    case 341:
        VERIFY(h,T_ITEM,"allowedSlot")
        ASSERT(REGS(63) >= 2)
        REGS(n) = oItem(h)->allowedSlot((int16)STACK(1), oCreature(STACK(2)));
        return;
    case 342:
        VERIFY(h,T_ITEM,"activeSlot")
        ASSERT(REGS(63) >= 1)
        REGS(n) = oItem(h)->activeSlot((int16)STACK(1));
        return;
    case 343:
        VERIFY(h,T_ITEM,"GetCharges")
        ASSERT(REGS(63) >= 0)
        REGS(n) = oItem(h)->GetCharges();
        return;
    case 344:
        VERIFY(h,T_ITEM,"SetCharges")
        ASSERT(REGS(63) >= 1)
        oItem(h)->SetCharges((int8)STACK(1));
        return;
    case 345:
        VERIFY(h,T_ITEM,"MakeKnown")
        ASSERT(REGS(63) >= 1)
        oItem(h)->MakeKnown((uint8)STACK(1));
        return;
    case 346:
        VERIFY(h,T_ITEM,"SetKnown")
        ASSERT(REGS(63) >= 1)
        oItem(h)->SetKnown((uint8)STACK(1));
        return;
    case 347:
        VERIFY(h,T_ITEM,"isEdible")
        ASSERT(REGS(63) >= 1)
        REGS(n) = oItem(h)->isEdible(oCreature(STACK(1)));
        return;
    case 348:
        VERIFY(h,T_ITEM,"isMagic")
        ASSERT(REGS(63) >= 0)
        REGS(n) = oItem(h)->isMagic();
        return;
    case 349:
        VERIFY(h,T_ITEM,"MakeMagical")
        ASSERT(REGS(63) >= 2)
        oItem(h)->MakeMagical(STACK(1), (int16)STACK(2));
        return;
    case 350:
        VERIFY(h,T_ITEM,"Weight")
        ASSERT(REGS(63) >= 0)
        REGS(n) = oItem(h)->Weight();
        return;
    case 351:
        VERIFY(h,T_ITEM,"HasIFlag")
        ASSERT(REGS(63) >= 1)
        REGS(n) = oItem(h)->HasIFlag((uint8)STACK(1));
        return;
    case 352:
        VERIFY(h,T_ITEM,"useStrength")
        ASSERT(REGS(63) >= 0)
        REGS(n) = oItem(h)->useStrength();
        return;
    case 353:
        VERIFY(h,T_ITEM,"HasSpell")
        ASSERT(REGS(63) >= 1)
        REGS(n) = oItem(h)->HasSpell((int16)STACK(1));
        return;
    case 354:
        VERIFY(h,T_ITEM,"HasQuality")
        ASSERT(REGS(63) >= 1)
        REGS(n) = oItem(h)->HasQuality((int16)STACK(1));
        return;
    case 355:
        VERIFY(h,T_ITEM,"KnownQuality")
        ASSERT(REGS(63) >= 1)
        REGS(n) = oItem(h)->KnownQuality((int16)STACK(1));
        return;
    case 356:
        VERIFY(h,T_ITEM,"QualityOK")
        ASSERT(REGS(63) >= 2)
        REGS(n) = oItem(h)->QualityOK((int8)STACK(1), (uint8)STACK(2));
        return;
    case 357:
        VERIFY(h,T_ITEM,"AddQuality")
        ASSERT(REGS(63) >= 2)
        oItem(h)->AddQuality((int8)STACK(1), (int16)STACK(2));
        return;
    case 358:
        VERIFY(h,T_ITEM,"RemoveQuality")
        ASSERT(REGS(63) >= 1)
        oItem(h)->RemoveQuality((int8)STACK(1));
        return;
    case 359:
        VERIFY(h,T_ITEM,"PurgeAllQualities")
        ASSERT(REGS(63) >= 0)
        oItem(h)->PurgeAllQualities();
        return;
    case 360:
        VERIFY(h,T_ITEM,"ItemLevel")
        ASSERT(REGS(63) >= 0)
        REGS(n) = oItem(h)->ItemLevel();
        return;
    case 361:
        VERIFY(h,T_ITEM,"isGroup")
        ASSERT(REGS(63) >= 1)
        REGS(n) = oItem(h)->isGroup(STACK(1));
        return;
    case 362:
        VERIFY(h,T_ITEM,"GetCorpseType")
        ASSERT(REGS(63) >= 0)
        REGS(n) = oItem(h)->GetCorpseType();
        return;
    case 363:
        VERIFY(h,T_ITEM,"GetLightRange")
        ASSERT(REGS(63) >= 0)
        REGS(n) = oItem(h)->GetLightRange();
        return;
    case 364:
        VERIFY(h,T_ITEM,"GetQuantity")
        ASSERT(REGS(63) >= 0)
        REGS(n) = oItem(h)->GetQuantity();
        return;
    case 365:
        VERIFY(h,T_ITEM,"SetQuantity")
        ASSERT(REGS(63) >= 1)
        oItem(h)->SetQuantity((uint16)STACK(1));
        return;
    case 366:
        VERIFY(h,T_ITEM,"TakeOne")
        ASSERT(REGS(63) >= 0)
        t = oItem(h)->TakeOne();
        REGS(n) = t ? t->myHandle : 0;
        return;
    case 367:
        VERIFY(h,T_ITEM,"TryStack")
        ASSERT(REGS(63) >= 1)
        t = oItem(h)->TryStack(oItem(STACK(1)));
        REGS(n) = t ? t->myHandle : 0;
        return;
    case 368:
        VERIFY(h,T_ITEM,"isBlessed")
        ASSERT(REGS(63) >= 0)
        REGS(n) = oItem(h)->isBlessed();
        return;
    case 369:
        VERIFY(h,T_ITEM,"isCursed")
        ASSERT(REGS(63) >= 0)
        REGS(n) = oItem(h)->isCursed();
        return;
    case 370:
        VERIFY(h,T_ITEM,"isMaster")
        ASSERT(REGS(63) >= 0)
        REGS(n) = oItem(h)->isMaster();
        return;
    case 371:
        VERIFY(h,T_ITEM,"isKnown")
        ASSERT(REGS(63) >= 1)
        REGS(n) = oItem(h)->isKnown((int16)STACK(1));
        return;
    case 372:
        VERIFY(h,T_ITEM,"ReApply")
        ASSERT(REGS(63) >= 0)
        oItem(h)->ReApply();
        return;
    case 373:
        VERIFY(h,T_ITEM,"GetPlus")
        ASSERT(REGS(63) >= 0)
        REGS(n) = oItem(h)->GetPlus();
        return;
    case 374:
        VERIFY(h,T_ITEM,"GetInherentPlus")
        ASSERT(REGS(63) >= 0)
        REGS(n) = oItem(h)->GetInherentPlus();
        return;
    case 375:
        VERIFY(h,T_ITEM,"SetInherentPlus")
        ASSERT(REGS(63) >= 1)
        oItem(h)->SetInherentPlus((int8)STACK(1));
        return;
    case 376:
        VERIFY(h,T_ITEM,"ArmVal")
        ASSERT(REGS(63) >= 1)
        REGS(n) = oItem(h)->ArmVal((int16)STACK(1));
        return;
    case 377:
        VERIFY(h,T_ITEM,"ArmourPenalty")
        ASSERT(REGS(63) >= 1)
        REGS(n) = oItem(h)->ArmourPenalty(STACK(1)!=0);
        return;
    case 378:
        VERIFY(h,T_ITEM,"Hardness")
        ASSERT(REGS(63) >= 1)
        REGS(n) = oItem(h)->Hardness((int8)STACK(1));
        return;
    case 379:
        VERIFY(h,T_ITEM,"MaxHP")
        ASSERT(REGS(63) >= 0)
        REGS(n) = oItem(h)->MaxHP();
        return;
    case 380:
        VERIFY(h,T_ITEM,"MendHP")
        ASSERT(REGS(63) >= 1)
        oItem(h)->MendHP((int16)STACK(1));
        return;
    case 381:
        VERIFY(h,T_ITEM,"GetHP")
        ASSERT(REGS(63) >= 0)
        REGS(n) = oItem(h)->GetHP();
        return;
    case 382:
        VERIFY(h,T_ITEM,"VisibleID")
        ASSERT(REGS(63) >= 1)
        oItem(h)->VisibleID(oCreature(STACK(1)));
        return;
    case 383:
        VERIFY(h,T_ITEM,"isBaneOf")
        ASSERT(REGS(63) >= 1)
        REGS(n) = oItem(h)->isBaneOf((int16)STACK(1));
        return;
    case 384:
        VERIFY(h,T_ITEM,"SetBane")
        ASSERT(REGS(63) >= 1)
        oItem(h)->SetBane((int16)STACK(1));
        return;
    case 385:
        VERIFY(h,T_ITEM,"GetBane")
        ASSERT(REGS(63) >= 0)
        REGS(n) = oItem(h)->GetBane();
        return;
    case 386:
        VERIFY(h,T_CONTAIN,"getItem")
        ASSERT(REGS(63) >= 1)
        t = oContain(h)->getItem((int16)STACK(1));
        REGS(n) = t ? t->myHandle : 0;
        return;
    case 387:
        VERIFY(h,T_TRAP,"TriggerTrap")
        ASSERT(REGS(63) >= 2)
        REGS(n) = oTrap(h)->TriggerTrap(*pe, STACK(2)!=0);
        return;
    case 388:
        VERIFY(h,T_TRAP,"TrapLevel")
        ASSERT(REGS(63) >= 0)
        REGS(n) = oTrap(h)->TrapLevel();
        return;
    case 389:
        VERIFY(h,T_PORTAL,"EnterDir")
        ASSERT(REGS(63) >= 1)
        REGS(n) = oPortal(h)->EnterDir((int8)STACK(1));
        return;
    case 390:
        ASSERT(REGS(63) >= 1)
        T1->StopWatch((int16)STACK(1));
        return;
    case 391:
        ASSERT(REGS(63) >= 1)
        T1->SetMode((int16)STACK(1));
        return;
    case 392:
        ASSERT(REGS(63) >= 0)
        REGS(n) = T1->GetMode();
        return;
    case 393:
        ASSERT(REGS(63) >= 0)
        REGS(n) = T1->OffsetX();
        return;
    case 394:
        ASSERT(REGS(63) >= 0)
        REGS(n) = T1->OffsetY();
        return;
    case 395:
        ASSERT(REGS(63) >= 1)
        T1->SetWin((int16)STACK(1));
        return;
    case 396:
        ASSERT(REGS(63) >= 0)
        REGS(n) = T1->GetCharRaw();
        return;
    case 397:
        ASSERT(REGS(63) >= 3)
        T1->PutChar((int16)STACK(1), (int16)STACK(2), STACK(3));
        return;
    case 398:
        ASSERT(REGS(63) >= 3)
        T1->PutGlyph((int16)STACK(1), (int16)STACK(2), STACK(3));
        return;
    case 399:
        ASSERT(REGS(63) >= 2)
        REGS(n) = T1->GetGlyph((int16)STACK(1), (int16)STACK(2));
        return;
    case 400:
        ASSERT(REGS(63) >= 2)
        T1->GotoXY((int16)STACK(1), (int16)STACK(2));
        return;
    case 401:
        ASSERT(REGS(63) >= 0)
        T1->Clear();
        return;
    case 402:
        ASSERT(REGS(63) >= 1)
        T1->SetColor((uint16)STACK(1));
        return;
    case 403:
        ASSERT(REGS(63) >= 1)
        T1->Write(GETSTR(STACK(1)));
        return;
    case 404:
        ASSERT(REGS(63) >= 3)
        T1->WriteXY((int16)STACK(1), (int16)STACK(2), GETSTR(STACK(3)));
        return;
    case 405:
        ASSERT(REGS(63) >= 0)
        T1->CursorOn();
        return;
    case 406:
        ASSERT(REGS(63) >= 0)
        T1->CursorOff();
        return;
    case 407:
        ASSERT(REGS(63) >= 2)
        t = T1->ChooseTarget(GETSTR(STACK(1)), (int16)STACK(2));
        REGS(n) = t ? t->myHandle : 0;
        return;
    case 408:
        ASSERT(REGS(63) >= 4)
        REGS(n) = T1->EffectPrompt(*pe, (int16)STACK(2), STACK(3)!=0, GETSTR(STACK(4)));
        return;
    case 409:
        ASSERT(REGS(63) >= 4)
        t = T1->AcquisitionPrompt((int8)STACK(1), (int8)STACK(2), (int8)STACK(3), (int8)STACK(4));
        REGS(n) = t ? t->myHandle : 0;
        return;
    case 410:
        ASSERT(REGS(63) >= 2)
        GETSTR(-1) = T1->StringPrompt((int8)STACK(1), GETSTR(STACK(2)));
        return;
    case 411:
        ASSERT(REGS(63) >= 3)
        REGS(n) = T1->ChooseResource(GETSTR(STACK(1)), (int16)STACK(2), STACK(3));
        return;
    case 412:
        ASSERT(REGS(63) >= 3)
        T1->LOption(GETSTR(STACK(1)), (int16)STACK(2), GETSTR(STACK(3)));
        return;
    case 413:
        ASSERT(REGS(63) >= 0)
        T1->LOptionClear();
        return;
    case 414:
        ASSERT(REGS(63) >= 4)
        REGS(n) = T1->LMenu((int16)STACK(1), GETSTR(STACK(2)), (int8)STACK(3), GETSTR(STACK(4)));
        return;
    case 415:
        ASSERT(REGS(63) >= 4)
        REGS(n) = T1->LMultiSelect((int16)STACK(1), GETSTR(STACK(2)), (int8)STACK(3), GETSTR(STACK(4)));
        return;
    case 416:
        ASSERT(REGS(63) >= 0)
        REGS(n) = T1->FirstSelected();
        return;
    case 417:
        ASSERT(REGS(63) >= 0)
        REGS(n) = T1->NextSelected();
        return;
    case 418:
        ASSERT(REGS(63) >= 1)
        T1->HelpTopic(GETSTR(STACK(1)));
        return;
    case 419:
        ASSERT(REGS(63) >= 0)
        T1->RefreshMap();
        return;
    case 420:
        ASSERT(REGS(63) >= 0)
        T1->TermUpdate();
        return;
    case 421:
        ASSERT(REGS(63) >= 1)
        T1->Box(GETSTR(STACK(1)));
        return;
    case 422:
        ASSERT(REGS(63) >= 2)
        T1->InventoryManager(STACK(1)!=0, oContain(STACK(2)));
        return;
    case 423:
        VERIFY(h,T_GAME,"GetEffectID")
        ASSERT(REGS(63) >= 4)
        REGS(n) = oGame(h)->GetEffectID((int16)STACK(1), (int8)STACK(2), (int8)STACK(3), (int8)STACK(4));
        return;
    case 424:
        VERIFY(h,T_GAME,"GetMonID")
        ASSERT(REGS(63) >= 5)
        REGS(n) = oGame(h)->GetMonID((int16)STACK(1), (int8)STACK(2), (int8)STACK(3), (int8)STACK(4), (int16)STACK(5));
        return;
    case 425:
        VERIFY(h,T_GAME,"GetItemID")
        ASSERT(REGS(63) >= 4)
        REGS(n) = oGame(h)->GetItemID((int16)STACK(1), (int8)STACK(2), (int8)STACK(3), (int8)STACK(4));
        return;
    case 426:
        VERIFY(h,T_GAME,"GetMapID")
        ASSERT(REGS(63) >= 3)
        REGS(n) = oGame(h)->GetMapID((int16)STACK(1), (uint8)STACK(2), (int8)STACK(3));
        return;
    case 427:
        VERIFY(h,T_GAME,"GetTempID")
        ASSERT(REGS(63) >= 3)
        REGS(n) = oGame(h)->GetTempID((uint16)STACK(1), STACK(2), (int8)STACK(3));
        return;
    case 428:
        VERIFY(h,T_GAME,"GetPlayer")
        ASSERT(REGS(63) >= 1)
        t = oGame(h)->GetPlayer((int8)STACK(1));
        REGS(n) = t ? t->myHandle : 0;
        return;
    case 429:
        VERIFY(h,T_GAME,"EnterLimbo")
        ASSERT(REGS(63) >= 8)
        oGame(h)->EnterLimbo(STACK(1), (uint8)STACK(2), (uint8)STACK(3), STACK(4), (int8)STACK(5), (int8)STACK(6), STACK(7), GETSTR(STACK(8)));
        return;
    case 430:
        VERIFY(h,T_GAME,"SpellNum")
        ASSERT(REGS(63) >= 1)
        REGS(n) = oGame(h)->SpellNum(STACK(1));
        return;
    case 431:
        VERIFY(h,T_GAME,"SpellID")
        ASSERT(REGS(63) >= 1)
        REGS(n) = oGame(h)->SpellID((int16)STACK(1));
        return;
    case 432:
        VERIFY(h,T_GAME,"LastSpell")
        ASSERT(REGS(63) >= 0)
        REGS(n) = oGame(h)->LastSpell();
        return;
    case 433:
        VERIFY(h,T_GAME,"GetTurn")
        ASSERT(REGS(63) >= 0)
        REGS(n) = oGame(h)->GetTurn();
        return;
    case 434:
        VERIFY(h,T_EVENTINFO,"SetParam")
        ASSERT(REGS(63) >= 2)
        pe->SetParam((int16)STACK(1), oThing(STACK(2)));
        return;
    case 435:
        ASSERT(REGS(63) >= 2)
        REGS(n) = isResType(STACK(1), (int16)STACK(2));
        return;
    case 436:
        if (RES(h)->Type == T_TDUNGEON || 1)
          { REGS(n) = TDUN(h)->GetConst((int16)STACK(1)); return; }
        Error("Incorrect Resource Type: %s->GetConst",NAME(h));
       break;
    case 437:
        if (RES(h)->Type == T_TEFFECT)
          { REGS(n) = TEFF(h)->HasSource((int8)STACK(1)); return; }
        Error("Incorrect Resource Type: %s->HasSource",NAME(h));
       break;
    case 438:
        if (RES(h)->Type == T_TEFFECT)
          { REGS(n) = TEFF(h)->HasFlag((int16)STACK(1)); return; }
        Error("Incorrect Resource Type: %s->HasFlag",NAME(h));
       break;
    case 439:
        if (RES(h)->Type == T_TTERRAIN)
          { REGS(n) = TTER(h)->TerrainHasFlag((int16)STACK(1)); return; }
        Error("Incorrect Resource Type: %s->TerrainHasFlag",NAME(h));
       break;
    case 442:
        ASSERT(0 > h);
        ASSERT(h > -63);
        ASSERT(REGS(63) >= 1)
        GETSTR(-1) = GETSTR(-h).Capitalize(STACK(1)!=0);
        return;
    case 440:
        ASSERT(REGS(63) >= 2)
        GETSTR(-1) = Capitalize(GETSTR(STACK(1)), STACK(2)!=0);
        return;
    case 443:
        ASSERT(0 > h);
        ASSERT(h > -63);
        ASSERT(REGS(63) >= 2)
        GETSTR(-1) = GETSTR(-h).Replace(GETSTR(STACK(1)), GETSTR(STACK(2)));
        return;
    case 441:
        ASSERT(REGS(63) >= 3)
        GETSTR(-1) = Replace(GETSTR(STACK(1)), GETSTR(STACK(2)), GETSTR(STACK(3)));
        return;
    case 444:
        ASSERT(0 > h);
        ASSERT(h > -63);
        ASSERT(REGS(63) >= 0)
        GETSTR(-h).Empty();
        return;
    case 445:
        ASSERT(0 > h);
        ASSERT(h > -63);
        ASSERT(REGS(63) >= 1)
        REGS(n) = GETSTR(-h).strchr((int8)STACK(1));
        return;
    case 446:
        ASSERT(0 > h);
        ASSERT(h > -63);
        ASSERT(REGS(63) >= 0)
        REGS(n) = GETSTR(-h).GetLength();
        return;
    case 447:
        ASSERT(0 > h);
        ASSERT(h > -63);
        ASSERT(REGS(63) >= 0)
        REGS(n) = GETSTR(-h).GetTrueLength();
        return;
    case 449:
        ASSERT(0 > h);
        ASSERT(h > -63);
        ASSERT(REGS(63) >= 1)
        GETSTR(-1) = GETSTR(-h).Left(STACK(1));
        return;
    case 448:
        ASSERT(REGS(63) >= 2)
        GETSTR(-1) = Left(GETSTR(STACK(1)), STACK(2));
        return;
    case 451:
        ASSERT(0 > h);
        ASSERT(h > -63);
        ASSERT(REGS(63) >= 1)
        GETSTR(-1) = GETSTR(-h).Right(STACK(1));
        return;
    case 450:
        ASSERT(REGS(63) >= 2)
        GETSTR(-1) = Right(GETSTR(STACK(1)), STACK(2));
        return;
    case 453:
        ASSERT(0 > h);
        ASSERT(h > -63);
        ASSERT(REGS(63) >= 2)
        GETSTR(-1) = GETSTR(-h).Mid(STACK(1), STACK(2));
        return;
    case 452:
        ASSERT(REGS(63) >= 3)
        GETSTR(-1) = Mid(GETSTR(STACK(1)), STACK(2), STACK(3));
        return;
    case 455:
        ASSERT(0 > h);
        ASSERT(h > -63);
        ASSERT(REGS(63) >= 0)
        GETSTR(-1) = GETSTR(-h).Trim();
        return;
    case 454:
        ASSERT(REGS(63) >= 1)
        GETSTR(-1) = Trim(GETSTR(STACK(1)));
        return;
    case 457:
        ASSERT(0 > h);
        ASSERT(h > -63);
        ASSERT(REGS(63) >= 1)
        GETSTR(-1) = GETSTR(-h).Upto(GETSTR(STACK(1)));
        return;
    case 456:
        ASSERT(REGS(63) >= 2)
        GETSTR(-1) = Upto(GETSTR(STACK(1)), GETSTR(STACK(2)));
        return;
    case 459:
        ASSERT(0 > h);
        ASSERT(h > -63);
        ASSERT(REGS(63) >= 0)
        GETSTR(-1) = GETSTR(-h).Upper();
        return;
    case 458:
        ASSERT(REGS(63) >= 1)
        GETSTR(-1) = Upper(GETSTR(STACK(1)));
        return;
    case 461:
        ASSERT(0 > h);
        ASSERT(h > -63);
        ASSERT(REGS(63) >= 0)
        GETSTR(-1) = GETSTR(-h).Lower();
        return;
    case 460:
        ASSERT(REGS(63) >= 1)
        GETSTR(-1) = Lower(GETSTR(STACK(1)));
        return;
    case 463:
        ASSERT(0 > h);
        ASSERT(h > -63);
        ASSERT(REGS(63) >= 0)
        GETSTR(-1) = GETSTR(-h).Decolorize();
        return;
    case 462:
        ASSERT(REGS(63) >= 1)
        GETSTR(-1) = Decolorize(GETSTR(STACK(1)));
        return;
    case 464:
        ASSERT(REGS(63) >= 1)
        GETSTR(-1) = Format(GETSTR(STACK(1)),
                      VSTACK(2),VSTACK(3),VSTACK(4),VSTACK(5),VSTACK(6),VSTACK(7),VSTACK(8),VSTACK(9));
        return;
    case 465:
        ASSERT(REGS(63) >= 1)
        GETSTR(-1) = XPrint(GETSTR(STACK(1)),
                      VSTACK(2),VSTACK(3),VSTACK(4),VSTACK(5),VSTACK(6),VSTACK(7),VSTACK(8),VSTACK(9));
        return;
    case 466:
        ASSERT(REGS(63) >= 2)
        GETSTR(-1) = Pluralize(GETSTR(STACK(1)), STACK(2));
        return;
    case 467:
        ASSERT(REGS(63) >= 1)
        GETSTR(-1) = NAME(STACK(1));
        return;
    case 468:
        ASSERT(REGS(63) >= 1)
        GETSTR(-1) = DESC(STACK(1));
        return;
    case 469:
        ASSERT(REGS(63) >= 1)
        GETSTR(-1) = SkillName((int16)STACK(1));
        return;
    case 470:
        ASSERT(REGS(63) >= 1)
        GETSTR(-1) = DescribeSkill((int16)STACK(1));
        return;
    case 471:
        ASSERT(REGS(63) >= 1)
        PrintRect(CAST_RECT(STACK(1)));
        return;
    case 472:
        ASSERT(REGS(63) >= 3)
        REGS(n) = WithinRect(CAST_RECT(STACK(1)), (int16)STACK(2), (int16)STACK(3));
        return;
    case 474:
        ASSERT(REGS(63) >= 1)
        REGS(n) = random((int16)STACK(1));
        return;
    case 475:
        ASSERT(REGS(63) >= 1)
        t = GetHandle(oThing(STACK(1)));
        REGS(n) = t ? t->myHandle : 0;
        return;
    case 476:
        ASSERT(REGS(63) >= 1)
        REGS(n) = isValidHandle(STACK(1));
        return;
    case 477:
        ASSERT(REGS(63) >= 3)
        DPrint(*pe, GETSTR(STACK(2)), GETSTR(STACK(3)),
                      VSTACK(4),VSTACK(5),VSTACK(6),VSTACK(7),VSTACK(8),VSTACK(9),VSTACK(10),VSTACK(11));
        return;
    case 478:
        ASSERT(REGS(63) >= 3)
        VPrint(*pe, GETSTR(STACK(2)), GETSTR(STACK(3)),
                      VSTACK(4),VSTACK(5),VSTACK(6),VSTACK(7),VSTACK(8),VSTACK(9),VSTACK(10),VSTACK(11));
        return;
    case 479:
        ASSERT(REGS(63) >= 4)
        TPrint(*pe, GETSTR(STACK(2)), GETSTR(STACK(3)), GETSTR(STACK(4)),
                      VSTACK(5),VSTACK(6),VSTACK(7),VSTACK(8),VSTACK(9),VSTACK(10),VSTACK(11),VSTACK(12));
        return;
    case 480:
        ASSERT(REGS(63) >= 2)
        APrint(*pe, GETSTR(STACK(2)),
                      VSTACK(3),VSTACK(4),VSTACK(5),VSTACK(6),VSTACK(7),VSTACK(8),VSTACK(9),VSTACK(10));
        return;
    case 481:
        ASSERT(REGS(63) >= 2)
        SinglePrintXY(*pe, GETSTR(STACK(2)),
                      VSTACK(3),VSTACK(4),VSTACK(5),VSTACK(6),VSTACK(7),VSTACK(8),VSTACK(9),VSTACK(10));
        return;
    case 482:
        ASSERT(REGS(63) >= 1)
        REGS(n) = ResourceLevel(STACK(1));
        return;
    case 483:
        ASSERT(REGS(63) >= 1)
        Error(GETSTR(STACK(1)),
                      VSTACK(2),VSTACK(3),VSTACK(4),VSTACK(5),VSTACK(6),VSTACK(7),VSTACK(8),VSTACK(9));
        return;
    case 484:
        ASSERT(REGS(63) >= 1)
        Fatal(GETSTR(STACK(1)),
                      VSTACK(2),VSTACK(3),VSTACK(4),VSTACK(5),VSTACK(6),VSTACK(7),VSTACK(8),VSTACK(9));
        return;
    case 485:
        ASSERT(REGS(63) >= 1)
        REGS(n) = DirX((int16)STACK(1));
        return;
    case 486:
        ASSERT(REGS(63) >= 1)
        REGS(n) = DirY((int16)STACK(1));
        return;
    case 487:
        ASSERT(REGS(63) >= 2)
        REGS(n) = ResourceHasFlag(STACK(1), (int16)STACK(2));
        return;
    case 488:
        ASSERT(REGS(63) >= 2)
        REGS(n) = mID_isMType(STACK(1), STACK(2));
        return;
    case 489:
        ASSERT(REGS(63) >= 1)
        REGS(n) = PoisonDC(STACK(1));
        return;
    case 490:
        ASSERT(REGS(63) >= 1)
        REGS(n) = XCRtoCR(STACK(1));
        return;
    case 491:
        ASSERT(REGS(63) >= 1)
        REGS(n) = XCR((int16)STACK(1));
        return;
    case 492:
        ASSERT(REGS(63) >= 0)
        SetSilence();
        return;
    case 493:
        ASSERT(REGS(63) >= 0)
        UnsetSilence();
        return;
    case 494:
        ASSERT(REGS(63) >= 2)
        SetETarget(*pe, oThing(STACK(2)));
        return;
    case 495:
        ASSERT(REGS(63) >= 2)
        SetEVictim(*pe, oCreature(STACK(2)));
        return;
    case 496:
        ASSERT(REGS(63) >= 2)
        SetEActor(*pe, oCreature(STACK(2)));
        return;
    case 497:
        ASSERT(REGS(63) >= 2)
        SetEItem(*pe, oItem(STACK(2)));
        return;
    case 498:
        ASSERT(REGS(63) >= 2)
        SetEItem2(*pe, oItem(STACK(2)));
        return;
    case 499:
        ASSERT(REGS(63) >= 0)
        REGS(n) = nCandidates();
        return;
    case 500:
        ASSERT(REGS(63) >= 1)
        REGS(n) = GetCandidate((int16)STACK(1));
        return;
    case 501:
        ASSERT(REGS(63) >= 1)
        AddCandidate(STACK(1));
        return;
    case 502:
        ASSERT(REGS(63) >= 0)
        REGS(n) = RandCandidate();
        return;
    case 503:
        ASSERT(REGS(63) >= 0)
        ClearCandidates();
        return;
    case 504:
        ASSERT(REGS(63) >= 5)
        REGS(n) = Throw((int16)STACK(1), oObject(STACK(2)), oObject(STACK(3)), oObject(STACK(4)), oObject(STACK(5)));
        return;
    case 505:
        ASSERT(REGS(63) >= 7)
        REGS(n) = ThrowXY((int16)STACK(1), (int16)STACK(2), (int16)STACK(3), oObject(STACK(4)), oObject(STACK(5)), oObject(STACK(6)), oObject(STACK(7)));
        return;
    case 506:
        ASSERT(REGS(63) >= 6)
        REGS(n) = ThrowVal((int16)STACK(1), (int16)STACK(2), oObject(STACK(3)), oObject(STACK(4)), oObject(STACK(5)), oObject(STACK(6)));
        return;
    case 507:
        ASSERT(REGS(63) >= 6)
        REGS(n) = ThrowDir((int16)STACK(1), (int8)STACK(2), oObject(STACK(3)), oObject(STACK(4)), oObject(STACK(5)), oObject(STACK(6)));
        return;
    case 508:
        ASSERT(REGS(63) >= 6)
        REGS(n) = ThrowEff((int16)STACK(1), STACK(2), oObject(STACK(3)), oObject(STACK(4)), oObject(STACK(5)), oObject(STACK(6)));
        return;
    case 509:
        ASSERT(REGS(63) >= 7)
        REGS(n) = ThrowEffDir((int16)STACK(1), STACK(2), (int8)STACK(3), oObject(STACK(4)), oObject(STACK(5)), oObject(STACK(6)), oObject(STACK(7)));
        return;
    case 510:
        ASSERT(REGS(63) >= 8)
        REGS(n) = ThrowEffXY((int16)STACK(1), STACK(2), (int16)STACK(3), (int16)STACK(4), oObject(STACK(5)), oObject(STACK(6)), oObject(STACK(7)), oObject(STACK(8)));
        return;
    case 511:
        ASSERT(REGS(63) >= 7)
        REGS(n) = ThrowLoc((int16)STACK(1), (int16)STACK(2), (int16)STACK(3), oObject(STACK(4)), oObject(STACK(5)), oObject(STACK(6)), oObject(STACK(7)));
        return;
    case 512:
        ASSERT(REGS(63) >= 8)
        REGS(n) = ThrowDmg((int16)STACK(1), (int16)STACK(2), (int16)STACK(3), GETSTR(STACK(4)), oObject(STACK(5)), oObject(STACK(6)), oObject(STACK(7)), oObject(STACK(8)));
        return;
    case 513:
        ASSERT(REGS(63) >= 6)
        REGS(n) = ThrowTerraDmg((int16)STACK(1), (int16)STACK(2), (int16)STACK(3), GETSTR(STACK(4)), oObject(STACK(5)), STACK(6));
        return;
    case 514:
        ASSERT(REGS(63) >= 9)
        REGS(n) = ThrowDmgEff((int16)STACK(1), (int16)STACK(2), (int16)STACK(3), GETSTR(STACK(4)), STACK(5), oObject(STACK(6)), oObject(STACK(7)), oObject(STACK(8)), oObject(STACK(9)));
        return;
    case 515:
        ASSERT(REGS(63) >= 2)
        REGS(n) = ReThrow((int16)STACK(1), *pe);
        return;
    case 516:
        ASSERT(REGS(63) >= 3)
        REGS(n) = RedirectEff(*pe, STACK(2), (int16)STACK(3));
        return;
    case 517:
        ASSERT(REGS(63) >= 1)
        t = CreateItem(STACK(1));
        REGS(n) = t ? t->myHandle : 0;
        return;
    case 518:
        ASSERT(REGS(63) >= 1)
        t = CreateMonster(STACK(1));
        REGS(n) = t ? t->myHandle : 0;
        return;
    case 519:
        ASSERT(REGS(63) >= 1)
        t = CreateFeature(STACK(1));
        REGS(n) = t ? t->myHandle : 0;
        return;
    case 520:
        ASSERT(REGS(63) >= 1)
        t = CreateDoor(STACK(1));
        REGS(n) = t ? t->myHandle : 0;
        return;
    case 521:
        ASSERT(REGS(63) >= 1)
        t = CreatePortal(STACK(1));
        REGS(n) = t ? t->myHandle : 0;
        return;
    case 522:
        ASSERT(REGS(63) >= 2)
        t = CreateTrap(STACK(1), STACK(2));
        REGS(n) = t ? t->myHandle : 0;
        return;
    case 523:
        ASSERT(REGS(63) >= 4)
        t = GenDungeonItem((uint16)STACK(1), STACK(2), (int16)STACK(3), (int8)STACK(4));
        REGS(n) = t ? t->myHandle : 0;
        return;
    case 524:
        ASSERT(REGS(63) >= 4)
        t = GenChestItem((uint16)STACK(1), STACK(2), (int16)STACK(3), (int8)STACK(4));
        REGS(n) = t ? t->myHandle : 0;
        return;
    case 525:
        ASSERT(REGS(63) >= 2)
        t = InitShopkeeper(STACK(1), STACK(2));
        REGS(n) = t ? t->myHandle : 0;
        return;
    case 526:
        ASSERT(REGS(63) >= 0)
        SystemBreak();
        return;
    case 527:
        ASSERT(REGS(63) >= 1)
        REGS(n) = effectGivesStati(STACK(1));
        return;
    case 528:
        ASSERT(REGS(63) >= 1)
        REGS(n) = MMFeatLevels(STACK(1));
        return;
    case 529:
        ASSERT(REGS(63) >= 3)
        REGS(n) = LevelAdjust((int16)STACK(1), (int16)STACK(2), (int16)STACK(3));
        return;
    case 530:
        ASSERT(REGS(63) >= 0)
        REGS(n) = LastSkillCheckResult();
        return;
    case 531:
        ASSERT(REGS(63) >= 4)
        SetPVal(*pe, (int16)STACK(2), (int16)STACK(3), (int16)STACK(4));
        return;
      default:
        Error("Illegal member function call!");
      }
  }


void VMachine::GetMemberVar(int16 varid, hObj h, int8 n)
  {
    switch(varid)
      {
        case 0:
          REGS(n) = (oMap(h)->dID);
         break;
        case 1:
          REGS(n) = (oMap(h)->Depth);
         break;
        case 215:
          if (RES(h)->Type == T_TMONSTER || T_TMONSTER == T_RESOURCE)
            { REGS(n) = TMON(h)->Depth; break; }
          Error("Incorrect Resource Type: %s->Depth",NAME(h));
         break;
        case 4:
          REGS(n) = (oThing(h)->x);
         break;
        case 5:
          REGS(n) = (oThing(h)->y);
         break;
        case 10:
          REGS(n) = (oCreature(h)->mID);
         break;
        case 233:
          if (RES(h)->Type == T_TTEMPLATE || T_TTEMPLATE == T_RESOURCE)
            { REGS(n) = TTEM(h)->TType; break; }
          Error("Incorrect Resource Type: %s->TType",NAME(h));
         break;
        case 43:
          REGS(n) = (oFeature(h)->fID);
         break;
        case 8:
          REGS(n) = (oThing(h)->Flags);
         break;
        case 73:
          REGS(n) = (pe->eID);
         break;
        case 42:
          REGS(n) = (oTrap(h)->tID);
         break;
        case 214:
          if (RES(h)->Type == T_TMONSTER || T_TMONSTER == T_RESOURCE)
            { REGS(n) = TMON(h)->CR; break; }
          Error("Incorrect Resource Type: %s->CR",NAME(h));
         break;
        case 174:
          REGS(n) = (pe->enAlign);
         break;
        case 2:
          REGS(n) = (oThing(h)->m->myHandle);
         break;
        case 3:
          REGS(n) = (oThing(h)->Next);
         break;
        case 6:
          REGS(n) = (oThing(h)->Image);
         break;
        case 213:
          if (RES(h)->Type == T_TMONSTER || T_TMONSTER == T_RESOURCE)
            { REGS(n) = TMON(h)->Image; break; }
          if (RES(h)->Type == T_TITEM || T_TITEM == T_RESOURCE)
            { REGS(n) = TITEM(h)->Image; break; }
          if (RES(h)->Type == T_TFEATURE || T_TFEATURE == T_RESOURCE)
            { REGS(n) = TFEAT(h)->Image; break; }
          if (RES(h)->Type == T_TTERRAIN || T_TTERRAIN == T_RESOURCE)
            { REGS(n) = TTER(h)->Image; break; }
          Error("Incorrect Resource Type: %s->Image",NAME(h));
         break;
        case 7:
          REGS(n) = (oThing(h)->Timeout);
         break;
        case 9:
          GETSTR(-1) = (oThing(h)->Named);
         break;
        case 11:
          REGS(n) = (oCreature(h)->tmID);
         break;
        case 12:
          REGS(n) = (oCreature(h)->PartyID);
         break;
        case 13:
          REGS(n) = (oCreature(h)->cHP);
         break;
        case 14:
          REGS(n) = (oCreature(h)->mHP);
         break;
        case 15:
          REGS(n) = (oCreature(h)->Subdual);
         break;
        case 16:
          REGS(n) = (oCreature(h)->cFP);
         break;
        case 17:
          REGS(n) = (oCreature(h)->mMana);
         break;
        case 18:
          REGS(n) = (oCreature(h)->uMana);
         break;
        case 19:
          REGS(n) = (oCreature(h)->hMana);
         break;
        case 20:
          REGS(n) = (oCreature(h)->AoO);
         break;
        case 21:
          REGS(n) = (oCreature(h)->FFCount);
         break;
        case 22:
          REGS(n) = (oCreature(h)->StateFlags);
         break;
        case 52:
          REGS(n) = (pe->DType);
         break;
        case 36:
          REGS(n) = (oItem(h)->iID);
         break;
        case 23:
          REGS(n) = (oCreature(h)->SightRange);
         break;
        case 24:
          REGS(n) = (oCreature(h)->LightRange);
         break;
        case 25:
          REGS(n) = (oCreature(h)->ShadowRange);
         break;
        case 26:
          REGS(n) = (oCreature(h)->InfraRange);
         break;
        case 27:
          REGS(n) = (oCreature(h)->TremorRange);
         break;
        case 28:
          REGS(n) = (oCreature(h)->BlindRange);
         break;
        case 29:
          REGS(n) = (oCreature(h)->TelepRange);
         break;
        case 30:
          REGS(n) = (oCreature(h)->PercepRange);
         break;
        case 31:
          REGS(n) = (oCharacter(h)->Proficiencies);
         break;
        case 32:
          REGS(n) = (oCharacter(h)->GodID);
         break;
        case 72:
          REGS(n) = (pe->sp);
         break;
        case 33:
          REGS(n) = (oPlayer(h)->RaceID);
         break;
        case 34:
          REGS(n) = (oPlayer(h)->WizardMode);
         break;
        case 35:
          REGS(n) = (oPlayer(h)->formulaSeed);
         break;
        case 175:
          REGS(n) = (pe->enCR);
         break;
        case 37:
          REGS(n) = (oItem(h)->ieID);
         break;
        case 38:
          REGS(n) = (oItem(h)->IFlags);
         break;
        case 39:
          REGS(n) = (oItem(h)->Age);
         break;
        case 40:
          REGS(n) = (oDoor(h)->DoorFlags);
         break;
        case 41:
          REGS(n) = (oTrap(h)->TrapFlags);
         break;
        case 227:
          if (RES(h)->Type == T_TEFFECT || T_TEFFECT == T_RESOURCE)
            { REGS(n) = TEFF(h)->Purpose; break; }
          Error("Incorrect Resource Type: %s->Purpose",NAME(h));
         break;
        case 44:
          REGS(n) = (pe->Event);
         break;
        case 45:
          REGS(n) = (pe->EXVal);
         break;
        case 46:
          REGS(n) = (pe->EYVal);
         break;
        case 47:
          REGS(n) = (pe->ESpellNum);
         break;
        case 48:
          REGS(n) = (pe->EParam);
         break;
        case 49:
          REGS(n) = (pe->EDir);
         break;
        case 50:
          REGS(n) = (pe->vRoll);
         break;
        case 51:
          REGS(n) = (pe->AType);
         break;
        case 53:
          REGS(n) = (pe->vHit);
         break;
        case 54:
          REGS(n) = (pe->vDef);
         break;
        case 55:
          REGS(n) = (pe->vThreat);
         break;
        case 56:
          REGS(n) = (pe->vCrit);
         break;
        case 57:
          REGS(n) = (pe->vPenetrateBonus);
         break;
        case 58:
          REGS(n) = (pe->vRange);
         break;
        case 59:
          REGS(n) = (pe->vRadius);
         break;
        case 60:
          REGS(n) = (pe->vDuration);
         break;
        case 61:
          REGS(n) = (pe->vCasterLev);
         break;
        case 62:
          REGS(n) = (pe->vAlchemy);
         break;
        case 63:
          REGS(n) = (pe->vChainCount);
         break;
        case 64:
          REGS(n) = (pe->vChainMax);
         break;
        case 65:
          REGS(n) = (pe->efNum);
         break;
        case 66:
          REGS(n) = (pe->saveDC);
         break;
        case 67:
          REGS(n) = (pe->vDmg);
         break;
        case 68:
          REGS(n) = (pe->bDmg);
         break;
        case 69:
          REGS(n) = (pe->aDmg);
         break;
        case 70:
          REGS(n) = (pe->xDmg);
         break;
        case 71:
          REGS(n) = (pe->vMult);
         break;
        case 74:
          REGS(n) = (pe->isHit);
         break;
        case 75:
          REGS(n) = (pe->isCrit);
         break;
        case 76:
          REGS(n) = (pe->isFumble);
         break;
        case 77:
          REGS(n) = (pe->isBypass);
         break;
        case 78:
          REGS(n) = (pe->Died);
         break;
        case 79:
          REGS(n) = (pe->ADied);
         break;
        case 80:
          REGS(n) = (pe->Blocked);
         break;
        case 81:
          REGS(n) = (pe->Saved);
         break;
        case 82:
          REGS(n) = (pe->Immune);
         break;
        case 83:
          REGS(n) = (pe->Resist);
         break;
        case 84:
          REGS(n) = (pe->wasFriendly);
         break;
        case 85:
          REGS(n) = (pe->actUnseen);
         break;
        case 86:
          REGS(n) = (pe->vicUnseen);
         break;
        case 87:
          REGS(n) = (pe->Whirlwind);
         break;
        case 88:
          REGS(n) = (pe->Graze);
         break;
        case 89:
          REGS(n) = (pe->Stun);
         break;
        case 90:
          REGS(n) = (pe->actIncor);
         break;
        case 91:
          REGS(n) = (pe->vicIncor);
         break;
        case 92:
          REGS(n) = (pe->Ranged);
         break;
        case 93:
          REGS(n) = (pe->vicHeld);
         break;
        case 94:
          REGS(n) = (pe->isDir);
         break;
        case 95:
          REGS(n) = (pe->isLoc);
         break;
        case 96:
          REGS(n) = (pe->isActivation);
         break;
        case 97:
          REGS(n) = (pe->isSomething);
         break;
        case 98:
          REGS(n) = (pe->isWield);
         break;
        case 99:
          REGS(n) = (pe->isRemove);
         break;
        case 100:
          REGS(n) = (pe->isPeriodic);
         break;
        case 101:
          REGS(n) = (pe->isAoO);
         break;
        case 102:
          REGS(n) = (pe->isCleave);
         break;
        case 103:
          REGS(n) = (pe->isSurprise);
         break;
        case 104:
          REGS(n) = (pe->isFlatFoot);
         break;
        case 105:
          REGS(n) = (pe->isFlanking);
         break;
        case 106:
          REGS(n) = (pe->isGhostTouch);
         break;
        case 107:
          REGS(n) = (pe->actIllusion);
         break;
        case 108:
          REGS(n) = (pe->vicIllusion);
         break;
        case 109:
          REGS(n) = (pe->effIllusion);
         break;
        case 110:
          REGS(n) = (pe->illType);
         break;
        case 111:
          REGS(n) = (pe->isSeeking);
         break;
        case 112:
          REGS(n) = (pe->isFirstBlastXY);
         break;
        case 113:
          REGS(n) = (pe->isRepeatSpell);
         break;
        case 114:
          REGS(n) = (pe->isEBlessed);
         break;
        case 115:
          REGS(n) = (pe->isECursed);
         break;
        case 116:
          REGS(n) = (pe->isConf);
         break;
        case 117:
          REGS(n) = (pe->isHallu);
         break;
        case 118:
          REGS(n) = (pe->isItem);
         break;
        case 119:
          REGS(n) = (pe->isTrap);
         break;
        case 120:
          REGS(n) = (pe->isActOfGod);
         break;
        case 121:
          REGS(n) = (pe->isOffhand);
         break;
        case 122:
          REGS(n) = (pe->isEvaded);
         break;
        case 123:
          REGS(n) = (pe->isSneakAttack);
         break;
        case 124:
          REGS(n) = (pe->isWildMiss);
         break;
        case 125:
          REGS(n) = (pe->ignoreHardness);
         break;
        case 126:
          REGS(n) = (pe->halfHardness);
         break;
        case 127:
          REGS(n) = (pe->Silence);
         break;
        case 128:
          REGS(n) = (pe->Terse);
         break;
        case 129:
          REGS(n) = (pe->MM);
         break;
        case 130:
          REGS(n) = (pe->vDepth);
         break;
        case 131:
          REGS(n) = (pe->vLevel);
         break;
        case 132:
          REGS(n) = (pe->vAlign);
         break;
        case 133:
          GETSTR(-1) = (pe->GraveText);
         break;
        case 134:
          GETSTR(-1) = (pe->strDmg);
         break;
        case 135:
          GETSTR(-1) = (pe->strXDmg);
         break;
        case 136:
          GETSTR(-1) = (pe->strHit);
         break;
        case 137:
          GETSTR(-1) = (pe->strDef);
         break;
        case 138:
          GETSTR(-1) = (pe->strOpp1);
         break;
        case 139:
          GETSTR(-1) = (pe->strOpp2);
         break;
        case 140:
          GETSTR(-1) = (pe->strBlastDmg);
         break;
        case 141:
          GETSTR(-1) = (pe->nPrefix);
         break;
        case 142:
          GETSTR(-1) = (pe->nCursed);
         break;
        case 143:
          GETSTR(-1) = (pe->nPrequal);
         break;
        case 144:
          GETSTR(-1) = (pe->nPostqual);
         break;
        case 145:
          GETSTR(-1) = (pe->nNamed);
         break;
        case 146:
          GETSTR(-1) = (pe->nBase);
         break;
        case 147:
          GETSTR(-1) = (pe->nAppend);
         break;
        case 148:
          GETSTR(-1) = (pe->nOf);
         break;
        case 149:
          GETSTR(-1) = (pe->nAdjective);
         break;
        case 150:
          GETSTR(-1) = (pe->nFlavour);
         break;
        case 151:
          GETSTR(-1) = (pe->nInscrip);
         break;
        case 152:
          GETSTR(-1) = (pe->nMech);
         break;
        case 153:
          GETSTR(-1) = (pe->nArticle);
         break;
        case 154:
          GETSTR(-1) = (pe->nPlus);
         break;
        case 155:
          GETSTR(-1) = (pe->Text);
         break;
        case 156:
          REGS(n) = (pe->eval);
         break;
        case 157:
          REGS(n) = (pe->dval);
         break;
        case 158:
          REGS(n) = (pe->aval);
         break;
        case 159:
          REGS(n) = (pe->tval);
         break;
        case 160:
          REGS(n) = (pe->qval);
         break;
        case 161:
          REGS(n) = (pe->sval);
         break;
        case 162:
          REGS(n) = (pe->lval);
         break;
        case 163:
          REGS(n) = (pe->cval);
         break;
        case 164:
          REGS(n) = (pe->xval);
         break;
        case 165:
          REGS(n) = (pe->yval);
         break;
        case 166:
          REGS(n) = (pe->rval);
         break;
        case 167:
          REGS(n) = UNCAST_RECT((pe->cPanel));
         break;
        case 168:
          REGS(n) = UNCAST_RECT((pe->cMap));
         break;
        case 169:
          REGS(n) = UNCAST_RECT((pe->cRoom));
         break;
        case 170:
          REGS(n) = (pe->vVal);
         break;
        case 171:
          REGS(n) = (pe->vMag);
         break;
        case 172:
          REGS(n) = (pe->vObj);
         break;
        case 173:
          REGS(n) = (pe->cPart);
         break;
        case 176:
          REGS(n) = (pe->enDepth);
         break;
        case 177:
          REGS(n) = (pe->enFreaky);
         break;
        case 178:
          REGS(n) = (pe->enPurpose);
         break;
        case 179:
          REGS(n) = (pe->enSleep);
         break;
        case 180:
          REGS(n) = (pe->enTerrain);
         break;
        case 181:
          REGS(n) = (pe->enDesAmt);
         break;
        case 182:
          REGS(n) = (pe->enType);
         break;
        case 183:
          REGS(n) = (pe->epMinAmt);
         break;
        case 184:
          REGS(n) = (pe->epMaxAmt);
         break;
        case 185:
          REGS(n) = (pe->epAmt);
         break;
        case 186:
          REGS(n) = (pe->epFreaky);
         break;
        case 187:
          REGS(n) = (pe->epWeight);
         break;
        case 188:
          REGS(n) = (pe->epMType);
         break;
        case 189:
          REGS(n) = (pe->epSkillRoll);
         break;
        case 190:
          REGS(n) = (pe->epClassRoll);
         break;
        case 191:
          REGS(n) = (pe->epCurrXCR);
         break;
        case 192:
          REGS(n) = (pe->enID);
         break;
        case 193:
          REGS(n) = (pe->ep_mID);
         break;
        case 194:
          REGS(n) = (pe->ep_tID);
         break;
        case 195:
          REGS(n) = (pe->ep_tID2);
         break;
        case 196:
          REGS(n) = (pe->ep_tID3);
         break;
        case 197:
          REGS(n) = (pe->ep_hmID);
         break;
        case 198:
          REGS(n) = (pe->ep_htID);
         break;
        case 199:
          REGS(n) = (pe->ep_htID2);
         break;
        case 200:
          REGS(n) = (pe->ep_iID);
         break;
        case 201:
          REGS(n) = (pe->ep_pID);
         break;
        case 202:
          REGS(n) = (pe->enXCR);
         break;
        case 203:
          REGS(n) = (pe->epXCR);
         break;
        case 204:
          REGS(n) = (pe->eimXCR);
         break;
        case 205:
          REGS(n) = (pe->enFlags);
         break;
        case 206:
          REGS(n) = (pe->enConstraint);
         break;
        case 207:
          REGS(n) = (pe->chMaximize);
         break;
        case 208:
          REGS(n) = (pe->chBestOfTwo);
         break;
        case 209:
          REGS(n) = (pe->chList);
         break;
        case 210:
          REGS(n) = (pe->chSource);
         break;
        case 211:
          REGS(n) = (pe->chResult);
         break;
        case 212:
          REGS(n) = (pe->isAquaticContext);
         break;
        case 216:
          if (RES(h)->Type == T_TMONSTER || T_TMONSTER == T_RESOURCE)
            { REGS(n) = TMON(h)->Terrains; break; }
          Error("Incorrect Resource Type: %s->Terrains",NAME(h));
         break;
        case 217:
          if (RES(h)->Type == T_TMONSTER || T_TMONSTER == T_RESOURCE)
            { REGS(n) = TMON(h)->Hit; break; }
          Error("Incorrect Resource Type: %s->Hit",NAME(h));
         break;
        case 218:
          if (RES(h)->Type == T_TMONSTER || T_TMONSTER == T_RESOURCE)
            { REGS(n) = TMON(h)->Def; break; }
          Error("Incorrect Resource Type: %s->Def",NAME(h));
         break;
        case 219:
          if (RES(h)->Type == T_TMONSTER || T_TMONSTER == T_RESOURCE)
            { REGS(n) = TMON(h)->Arm; break; }
          Error("Incorrect Resource Type: %s->Arm",NAME(h));
         break;
        case 220:
          if (RES(h)->Type == T_TMONSTER || T_TMONSTER == T_RESOURCE)
            { REGS(n) = TMON(h)->Mov; break; }
          Error("Incorrect Resource Type: %s->Mov",NAME(h));
         break;
        case 221:
          if (RES(h)->Type == T_TMONSTER || T_TMONSTER == T_RESOURCE)
            { REGS(n) = TMON(h)->Spd; break; }
          Error("Incorrect Resource Type: %s->Spd",NAME(h));
         break;
        case 222:
          if (RES(h)->Type == T_TMONSTER || T_TMONSTER == T_RESOURCE)
            { REGS(n) = TMON(h)->MSize; break; }
          Error("Incorrect Resource Type: %s->MSize",NAME(h));
         break;
        case 224:
          if (RES(h)->Type == T_TITEM || T_TITEM == T_RESOURCE)
            { REGS(n) = TITEM(h)->RIType; break; }
          Error("Incorrect Resource Type: %s->RIType",NAME(h));
         break;
        case 226:
          if (RES(h)->Type == T_TEFFECT || T_TEFFECT == T_RESOURCE)
            { REGS(n) = TEFF(h)->Schools; break; }
          Error("Incorrect Resource Type: %s->Schools",NAME(h));
         break;
        case 228:
          if (RES(h)->Type == T_TEFFECT || T_TEFFECT == T_RESOURCE)
            { REGS(n) = TEFF(h)->Level; break; }
          Error("Incorrect Resource Type: %s->Level",NAME(h));
         break;
        case 230:
          if (RES(h)->Type == T_TREGION || T_TREGION == T_RESOURCE)
            { REGS(n) = TREG(h)->Floor; break; }
          Error("Incorrect Resource Type: %s->Floor",NAME(h));
         break;
        case 231:
          if (RES(h)->Type == T_TREGION || T_TREGION == T_RESOURCE)
            { REGS(n) = TREG(h)->Walls; break; }
          Error("Incorrect Resource Type: %s->Walls",NAME(h));
         break;
        case 232:
          if (RES(h)->Type == T_TRACE || T_TRACE == T_RESOURCE)
            { REGS(n) = TRACE(h)->BaseRace; break; }
          Error("Incorrect Resource Type: %s->BaseRace",NAME(h));
         break;
      default:
        Error("Illegal member variable access!");
      }
  }


void VMachine::SetMemberVar(int16 varid, hObj h, int32 val)
  {
    switch(varid)
      {
        case 0:
          oMap(h)->dID = val;
         break;
        case 1:
          oMap(h)->Depth = (int16)val;
         break;
        case 4:
          oThing(h)->x = (int16)val;
         break;
        case 5:
          oThing(h)->y = (int16)val;
         break;
        case 10:
          oCreature(h)->mID = val;
         break;
        case 43:
          oFeature(h)->fID = val;
         break;
        case 8:
          oThing(h)->Flags = val;
         break;
        case 73:
          pe->eID = val;
         break;
        case 42:
          oTrap(h)->tID = val;
         break;
        case 174:
          pe->enAlign = (int16)val;
         break;
        case 2:
          oThing(h)->m = oMap(val);
         break;
        case 3:
          oThing(h)->Next = val;
         break;
        case 6:
          oThing(h)->Image = val;
         break;
        case 7:
          oThing(h)->Timeout = (int16)val;
         break;
        case 9:
          oThing(h)->Named = GETSTR(val);
         break;
        case 11:
          oCreature(h)->tmID = val;
         break;
        case 12:
          oCreature(h)->PartyID = (int16)val;
         break;
        case 13:
          oCreature(h)->cHP = (int16)val;
         break;
        case 14:
          oCreature(h)->mHP = (int16)val;
         break;
        case 15:
          oCreature(h)->Subdual = (int16)val;
         break;
        case 16:
          oCreature(h)->cFP = (int16)val;
         break;
        case 17:
          oCreature(h)->mMana = val;
         break;
        case 18:
          oCreature(h)->uMana = val;
         break;
        case 19:
          oCreature(h)->hMana = val;
         break;
        case 20:
          oCreature(h)->AoO = (int8)val;
         break;
        case 21:
          oCreature(h)->FFCount = (int8)val;
         break;
        case 22:
          oCreature(h)->StateFlags = (int16)val;
         break;
        case 52:
          pe->DType = (int8)val;
         break;
        case 36:
          oItem(h)->iID = val;
         break;
        case 23:
          oCreature(h)->SightRange = (int8)val;
         break;
        case 24:
          oCreature(h)->LightRange = (int8)val;
         break;
        case 25:
          oCreature(h)->ShadowRange = (int8)val;
         break;
        case 26:
          oCreature(h)->InfraRange = (int8)val;
         break;
        case 27:
          oCreature(h)->TremorRange = (int8)val;
         break;
        case 28:
          oCreature(h)->BlindRange = (int8)val;
         break;
        case 29:
          oCreature(h)->TelepRange = (int8)val;
         break;
        case 30:
          oCreature(h)->PercepRange = (int8)val;
         break;
        case 31:
          oCharacter(h)->Proficiencies = val;
         break;
        case 32:
          oCharacter(h)->GodID = val;
         break;
        case 72:
          pe->sp = (int16)val;
         break;
        case 33:
          oPlayer(h)->RaceID = val;
         break;
        case 34:
          oPlayer(h)->WizardMode = val!=0;
         break;
        case 35:
          oPlayer(h)->formulaSeed = val;
         break;
        case 175:
          pe->enCR = (int16)val;
         break;
        case 37:
          oItem(h)->ieID = val;
         break;
        case 38:
          oItem(h)->IFlags = (int16)val;
         break;
        case 39:
          oItem(h)->Age = (int16)val;
         break;
        case 40:
          oDoor(h)->DoorFlags = (int8)val;
         break;
        case 41:
          oTrap(h)->TrapFlags = (uint8)val;
         break;
        case 44:
          pe->Event = (int16)val;
         break;
        case 45:
          pe->EXVal = (int16)val;
         break;
        case 46:
          pe->EYVal = (int16)val;
         break;
        case 47:
          pe->ESpellNum = (int16)val;
         break;
        case 48:
          pe->EParam = val;
         break;
        case 49:
          pe->EDir = (int16)val;
         break;
        case 50:
          pe->vRoll = (int8)val;
         break;
        case 51:
          pe->AType = (int8)val;
         break;
        case 53:
          pe->vHit = (int8)val;
         break;
        case 54:
          pe->vDef = (int8)val;
         break;
        case 55:
          pe->vThreat = (int8)val;
         break;
        case 56:
          pe->vCrit = (int8)val;
         break;
        case 57:
          pe->vPenetrateBonus = (int8)val;
         break;
        case 58:
          pe->vRange = (int8)val;
         break;
        case 59:
          pe->vRadius = (int8)val;
         break;
        case 60:
          pe->vDuration = (int16)val;
         break;
        case 61:
          pe->vCasterLev = (int8)val;
         break;
        case 62:
          pe->vAlchemy = (int8)val;
         break;
        case 63:
          pe->vChainCount = (int8)val;
         break;
        case 64:
          pe->vChainMax = (int8)val;
         break;
        case 65:
          pe->efNum = (int8)val;
         break;
        case 66:
          pe->saveDC = (int8)val;
         break;
        case 67:
          pe->vDmg = (int16)val;
         break;
        case 68:
          pe->bDmg = (int16)val;
         break;
        case 69:
          pe->aDmg = (int16)val;
         break;
        case 70:
          pe->xDmg = (int16)val;
         break;
        case 71:
          pe->vMult = (int16)val;
         break;
        case 74:
          pe->isHit = val!=0;
         break;
        case 75:
          pe->isCrit = val!=0;
         break;
        case 76:
          pe->isFumble = val!=0;
         break;
        case 77:
          pe->isBypass = val!=0;
         break;
        case 78:
          pe->Died = val!=0;
         break;
        case 79:
          pe->ADied = val!=0;
         break;
        case 80:
          pe->Blocked = val!=0;
         break;
        case 81:
          pe->Saved = val!=0;
         break;
        case 82:
          pe->Immune = val!=0;
         break;
        case 83:
          pe->Resist = val!=0;
         break;
        case 84:
          pe->wasFriendly = val!=0;
         break;
        case 85:
          pe->actUnseen = val!=0;
         break;
        case 86:
          pe->vicUnseen = val!=0;
         break;
        case 87:
          pe->Whirlwind = val!=0;
         break;
        case 88:
          pe->Graze = val!=0;
         break;
        case 89:
          pe->Stun = val!=0;
         break;
        case 90:
          pe->actIncor = val!=0;
         break;
        case 91:
          pe->vicIncor = val!=0;
         break;
        case 92:
          pe->Ranged = val!=0;
         break;
        case 93:
          pe->vicHeld = val!=0;
         break;
        case 94:
          pe->isDir = val!=0;
         break;
        case 95:
          pe->isLoc = val!=0;
         break;
        case 96:
          pe->isActivation = val!=0;
         break;
        case 97:
          pe->isSomething = val!=0;
         break;
        case 98:
          pe->isWield = val!=0;
         break;
        case 99:
          pe->isRemove = val!=0;
         break;
        case 100:
          pe->isPeriodic = val!=0;
         break;
        case 101:
          pe->isAoO = val!=0;
         break;
        case 102:
          pe->isCleave = val!=0;
         break;
        case 103:
          pe->isSurprise = val!=0;
         break;
        case 104:
          pe->isFlatFoot = val!=0;
         break;
        case 105:
          pe->isFlanking = val!=0;
         break;
        case 106:
          pe->isGhostTouch = val!=0;
         break;
        case 107:
          pe->actIllusion = val!=0;
         break;
        case 108:
          pe->vicIllusion = val!=0;
         break;
        case 109:
          pe->effIllusion = val!=0;
         break;
        case 110:
          pe->illType = val!=0;
         break;
        case 111:
          pe->isSeeking = val!=0;
         break;
        case 112:
          pe->isFirstBlastXY = val!=0;
         break;
        case 113:
          pe->isRepeatSpell = val!=0;
         break;
        case 114:
          pe->isEBlessed = val!=0;
         break;
        case 115:
          pe->isECursed = val!=0;
         break;
        case 116:
          pe->isConf = val!=0;
         break;
        case 117:
          pe->isHallu = val!=0;
         break;
        case 118:
          pe->isItem = val!=0;
         break;
        case 119:
          pe->isTrap = val!=0;
         break;
        case 120:
          pe->isActOfGod = val!=0;
         break;
        case 121:
          pe->isOffhand = val!=0;
         break;
        case 122:
          pe->isEvaded = val!=0;
         break;
        case 123:
          pe->isSneakAttack = val!=0;
         break;
        case 124:
          pe->isWildMiss = val!=0;
         break;
        case 125:
          pe->ignoreHardness = val!=0;
         break;
        case 126:
          pe->halfHardness = val!=0;
         break;
        case 127:
          pe->Silence = val!=0;
         break;
        case 128:
          pe->Terse = val!=0;
         break;
        case 129:
          pe->MM = val;
         break;
        case 130:
          pe->vDepth = (int16)val;
         break;
        case 131:
          pe->vLevel = (int16)val;
         break;
        case 132:
          pe->vAlign = (int16)val;
         break;
        case 133:
          pe->GraveText = GETSTR(val);
         break;
        case 134:
          pe->strDmg = GETSTR(val);
         break;
        case 135:
          pe->strXDmg = GETSTR(val);
         break;
        case 136:
          pe->strHit = GETSTR(val);
         break;
        case 137:
          pe->strDef = GETSTR(val);
         break;
        case 138:
          pe->strOpp1 = GETSTR(val);
         break;
        case 139:
          pe->strOpp2 = GETSTR(val);
         break;
        case 140:
          pe->strBlastDmg = GETSTR(val);
         break;
        case 141:
          pe->nPrefix = GETSTR(val);
         break;
        case 142:
          pe->nCursed = GETSTR(val);
         break;
        case 143:
          pe->nPrequal = GETSTR(val);
         break;
        case 144:
          pe->nPostqual = GETSTR(val);
         break;
        case 145:
          pe->nNamed = GETSTR(val);
         break;
        case 146:
          pe->nBase = GETSTR(val);
         break;
        case 147:
          pe->nAppend = GETSTR(val);
         break;
        case 148:
          pe->nOf = GETSTR(val);
         break;
        case 149:
          pe->nAdjective = GETSTR(val);
         break;
        case 150:
          pe->nFlavour = GETSTR(val);
         break;
        case 151:
          pe->nInscrip = GETSTR(val);
         break;
        case 152:
          pe->nMech = GETSTR(val);
         break;
        case 153:
          pe->nArticle = GETSTR(val);
         break;
        case 154:
          pe->nPlus = GETSTR(val);
         break;
        case 155:
          pe->Text = GETSTR(val);
         break;
        case 156:
          pe->eval = (int8)val;
         break;
        case 157:
          pe->dval = (int8)val;
         break;
        case 158:
          pe->aval = (int8)val;
         break;
        case 159:
          pe->tval = (int8)val;
         break;
        case 160:
          pe->qval = (int8)val;
         break;
        case 161:
          pe->sval = (int8)val;
         break;
        case 162:
          pe->lval = (int8)val;
         break;
        case 163:
          pe->cval = (int8)val;
         break;
        case 164:
          pe->xval = (uint8)val;
         break;
        case 165:
          pe->yval = (int16)val;
         break;
        case 166:
          pe->rval = val;
         break;
        case 167:
          pe->cPanel = CAST_RECT(val);
         break;
        case 168:
          pe->cMap = CAST_RECT(val);
         break;
        case 169:
          pe->cRoom = CAST_RECT(val);
         break;
        case 170:
          pe->vVal = val;
         break;
        case 171:
          pe->vMag = val;
         break;
        case 172:
          pe->vObj = val;
         break;
        case 173:
          pe->cPart = (int16)val;
         break;
        case 176:
          pe->enDepth = (int16)val;
         break;
        case 177:
          pe->enFreaky = (int16)val;
         break;
        case 178:
          pe->enPurpose = (int16)val;
         break;
        case 179:
          pe->enSleep = (int16)val;
         break;
        case 180:
          pe->enTerrain = val;
         break;
        case 181:
          pe->enDesAmt = (int16)val;
         break;
        case 182:
          pe->enType = (int16)val;
         break;
        case 183:
          pe->epMinAmt = (int16)val;
         break;
        case 184:
          pe->epMaxAmt = (int16)val;
         break;
        case 185:
          pe->epAmt = (int16)val;
         break;
        case 186:
          pe->epFreaky = (int16)val;
         break;
        case 187:
          pe->epWeight = (int16)val;
         break;
        case 188:
          pe->epMType = (int16)val;
         break;
        case 189:
          pe->epSkillRoll = (int16)val;
         break;
        case 190:
          pe->epClassRoll = (int16)val;
         break;
        case 191:
          pe->epCurrXCR = (int16)val;
         break;
        case 192:
          pe->enID = val;
         break;
        case 193:
          pe->ep_mID = val;
         break;
        case 194:
          pe->ep_tID = val;
         break;
        case 195:
          pe->ep_tID2 = val;
         break;
        case 196:
          pe->ep_tID3 = val;
         break;
        case 197:
          pe->ep_hmID = val;
         break;
        case 198:
          pe->ep_htID = val;
         break;
        case 199:
          pe->ep_htID2 = val;
         break;
        case 200:
          pe->ep_iID = val;
         break;
        case 201:
          pe->ep_pID = val;
         break;
        case 202:
          pe->enXCR = val;
         break;
        case 203:
          pe->epXCR = val;
         break;
        case 204:
          pe->eimXCR = val;
         break;
        case 205:
          pe->enFlags = val;
         break;
        case 206:
          pe->enConstraint = val;
         break;
        case 207:
          pe->chMaximize = val!=0;
         break;
        case 208:
          pe->chBestOfTwo = val!=0;
         break;
        case 209:
          pe->chList = (int16)val;
         break;
        case 210:
          pe->chSource = val;
         break;
        case 211:
          pe->chResult = val;
         break;
        case 212:
          pe->isAquaticContext = val!=0;
         break;
      default:
        Error("Illegal member variable access!");
      }
  }


